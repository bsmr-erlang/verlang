diff -aurN coq-8.4pl2-pristine/ide/coq_lex.mll coq-8.4pl2-new/ide/coq_lex.mll
--- coq-8.4pl2-pristine/ide/coq_lex.mll	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/ide/coq_lex.mll	2013-06-03 04:29:10.207721636 -0700
@@ -0,0 +1,195 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+{
+  open Lexing
+
+  type token =
+    | Comment
+    | Keyword
+    | Declaration
+    | ProofDeclaration
+    | Qed
+    | String
+
+  (* Without this table, the automaton would be too big and
+     ocamllex would fail *)
+
+  let tag_of_ident =
+    let one_word_commands =
+      [ "Add" ; "Check"; "Eval"; "Extraction" ;
+	"Load" ; "Undo"; "Goal";
+	"Proof" ; "Print";"Save" ; "Restart";
+	"End" ; "Section"; "Chapter"; "Transparent"; "Opaque"; "Comments" ]
+    in
+    let one_word_declarations =
+      [ (* Definitions *)
+	"Definition" ; "Let" ; "Example" ; "SubClass" ;
+        "Fixpoint" ; "CoFixpoint" ; "Scheme" ; "Function" ;
+        (* Assumptions *)
+	"Hypothesis" ; "Variable" ; "Axiom" ; "Parameter" ; "Conjecture" ;
+	"Hypotheses" ; "Variables" ; "Axioms" ; "Parameters";
+        (* Inductive *)
+        "Inductive" ; "CoInductive" ; "Record" ; "Structure" ;
+        (* Other *)
+	"Ltac" ; "Instance"; "Include"; "Context"; "Class" ;
+	 "Arguments" ]
+    in
+    let proof_declarations =
+      [ "Theorem" ; "Lemma" ; " Fact" ; "Remark" ; "Corollary" ;
+        "Proposition" ; "Property" ]
+    in
+    let proof_ends =
+      [ "Qed" ; "Defined" ; "Admitted"; "Abort" ]
+    in
+    let constr_keywords =
+      [ "forall"; "fun"; "match"; "fix"; "cofix"; "with"; "for";
+	"end"; "as"; "let"; "in"; "if"; "then"; "else"; "return";
+	"Prop"; "Set"; "Type" ]
+    in
+    let h = Hashtbl.create 97 in (* for vernac *)
+    let h' = Hashtbl.create 97 in (* for constr *)
+    List.iter (fun s -> Hashtbl.add h s Keyword) one_word_commands;
+    List.iter (fun s -> Hashtbl.add h s Declaration) one_word_declarations;
+    List.iter (fun s -> Hashtbl.add h s ProofDeclaration) proof_declarations;
+    List.iter (fun s -> Hashtbl.add h s Qed) proof_ends;
+    List.iter (fun s -> Hashtbl.add h' s Keyword) constr_keywords;
+    (fun initial id -> Hashtbl.find (if initial then h else h') id)
+
+  exception Unterminated
+
+  let here f lexbuf = f (Lexing.lexeme_start lexbuf) (Lexing.lexeme_end lexbuf)
+
+}
+
+let space =
+  [' ' '\n' '\r' '\t' '\012'] (* '\012' is form-feed *)
+
+let firstchar =
+  ['$' 'A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255']
+let identchar =
+  ['$' 'A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
+let ident = firstchar identchar*
+
+let undotted_sep = [ '{' '}' '-' '+' '*' ]
+
+let dot_sep = '.' (space | eof)
+
+let multiword_declaration =
+  "Module" (space+ "Type")?
+| "Program" space+ ident
+| "Existing" space+ "Instance" "s"?
+| "Canonical" space+ "Structure"
+
+let locality = (space+ "Local")?
+
+let multiword_command =
+  ("Uns" | "S")" et" (space+ ident)*
+| (("Open" | "Close") locality | "Bind" | " Delimit" )
+    space+ "Scope"
+| (("Reserved" space+)? "Notation" | "Infix") locality space+
+| "Next" space+ "Obligation"
+| "Solve" space+ "Obligations"
+| "Require" space+ ("Import"|"Export")?
+| "Hint" locality space+ ident
+| "Reset" (space+ "Initial")?
+| "Tactic" space+ "Notation"
+| "Implicit" space+ "Type" "s"?
+| "Combined" space+ "Scheme"
+| "Extraction" space+ (("Language" space+ ("Ocaml"|"Haskell"|"Scheme"|"CoreErlang"|"Toplevel"))|
+    ("Library"|"Inline"|"NoInline"|"Blacklist"))
+| "Recursive" space+ "Extraction" (space+ "Library")?
+| ("Print"|"Reset") space+ "Extraction" space+ ("Inline"|"Blacklist")
+| "Extract" space+ (("Inlined" space+) "Constant"| "Inductive")
+| "Typeclasses" space+ ("eauto" | "Transparent" | "Opaque")
+| ("Generalizable" space+) ("All" | "No")? "Variable" "s"?
+
+(* At least still missing: "Inline" + decl, variants of "Identity
+  Coercion", variants of Print, Add, ... *)
+
+rule coq_string = parse
+  | "\"\"" { coq_string lexbuf }
+  | "\"" { Lexing.lexeme_end lexbuf }
+  | eof { Lexing.lexeme_end lexbuf }
+  | _ { coq_string lexbuf }
+
+and comment = parse
+  | "(*" { ignore (comment lexbuf); comment lexbuf }
+  | "\"" { ignore (coq_string lexbuf); comment lexbuf }
+  | "*)" { (true, Lexing.lexeme_start lexbuf + 2) }
+  | eof { (false, Lexing.lexeme_end lexbuf) }
+  | _ { comment lexbuf }
+
+and sentence initial stamp = parse
+  | "(*" {
+      let comm_start = Lexing.lexeme_start lexbuf in
+      let trully_terminated,comm_end = comment lexbuf in
+      stamp comm_start comm_end Comment;
+      if not trully_terminated then raise Unterminated;
+      (* A comment alone is a sentence.
+	 A comment in a sentence doesn't terminate the sentence.
+         Note: comm_end is the first position _after_ the comment,
+	 as required when tagging a zone, hence the -1 to locate the
+	 ")" terminating the comment.
+      *)
+      if initial then comm_end - 1 else sentence false stamp lexbuf
+    }
+  | "\"" {
+      let str_start = Lexing.lexeme_start lexbuf in
+      let str_end = coq_string lexbuf in
+      stamp str_start str_end String;
+      sentence false stamp lexbuf
+    }
+  | multiword_declaration {
+      if initial then here stamp lexbuf Declaration;
+      sentence false stamp lexbuf
+    }
+  | multiword_command {
+      if initial then here stamp lexbuf Keyword;
+      sentence false stamp lexbuf
+    }
+  | ident as id {
+      (try here stamp lexbuf (tag_of_ident initial id) with Not_found -> ());
+      sentence false stamp lexbuf }
+  | ".." {
+      (* We must have a particular rule for parsing "..", where no dot
+	 is a terminator, even if we have a blank afterwards
+	 (cf. for instance the syntax for recursive notation).
+	 This rule and the following one also allow to treat the "..."
+	 special case, where the third dot is a terminator. *)
+      sentence false stamp lexbuf
+    }
+  | dot_sep { Lexing.lexeme_start lexbuf } (* The usual "." terminator *)
+  | undotted_sep {
+      (* Separators like { or } and bullets * - + are only active
+	 at the start of a sentence *)
+      if initial then Lexing.lexeme_start lexbuf
+      else sentence false stamp lexbuf
+    }
+  | space+ {
+       (* Parsing spaces is the only situation preserving initiality *)
+       sentence initial stamp lexbuf
+    }
+  | _ {
+      (* Any other characters *)
+      sentence false stamp lexbuf
+    }
+  | eof { raise Unterminated }
+
+{
+
+  (** Parse a sentence in string [slice], tagging relevant parts with
+      function [stamp], and returning the position of the first
+      sentence delimitor (either "." or "{" or "}" or the end of a comment).
+      It will raise [Unterminated] when no end of sentence is found.
+  *)
+
+  let delimit_sentence stamp slice =
+    sentence true stamp (Lexing.from_string slice)
+
+}
diff -aurN coq-8.4pl2-pristine/plugins/extraction/common.ml coq-8.4pl2-new/plugins/extraction/common.ml
--- coq-8.4pl2-pristine/plugins/extraction/common.ml	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/common.ml	2013-07-15 08:44:39.408126738 -0700
@@ -0,0 +1,638 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+open Pp
+open Util
+open Names
+open Term
+open Declarations
+open Namegen
+open Nameops
+open Libnames
+open Table
+open Miniml
+open Mlutil
+open Modutil
+open Mod_subst
+
+let string_of_id id =
+  let s = Names.string_of_id id in
+  for i = 0 to String.length s - 2 do
+    if s.[i] = '_' && s.[i+1] = '_' then warning_id s
+  done;
+  ascii_of_ident s
+
+let is_mp_bound = function MPbound _ -> true | _ -> false
+
+(*s Some pretty-print utility functions. *)
+
+let pp_par par st = if par then str "(" ++ st ++ str ")" else st
+
+(** [pp_apply] : a head part applied to arguments, possibly with parenthesis *)
+
+let pp_apply st par args = match args with
+  | [] -> st
+  | _  -> hov 2 (pp_par par (st ++ spc () ++ prlist_with_sep spc identity args))
+
+(** Same as [pp_apply], but with also protection of the head by parenthesis *)
+
+let pp_apply2 st par args =
+  let par' = args <> [] || par in
+  pp_apply (pp_par par' st) par args
+
+let pr_binding = function
+  | [] -> mt ()
+  | l  -> str " " ++ prlist_with_sep (fun () -> str " ") pr_id l
+
+let pp_tuple_light f = function
+  | [] -> mt ()
+  | [x] -> f true x
+  | l ->
+      pp_par true (prlist_with_sep (fun () -> str "," ++ spc ()) (f false) l)
+
+let pp_tuple f = function
+  | [] -> mt ()
+  | [x] -> f x
+  | l -> pp_par true (prlist_with_sep (fun () -> str "," ++ spc ()) f l)
+
+let pp_boxed_tuple f = function
+  | [] -> mt ()
+  | [x] -> f x
+  | l -> pp_par true (hov 0 (prlist_with_sep (fun () -> str "," ++ spc ()) f l))
+
+(** By default, in module Format, you can do horizontal placing of blocks
+    even if they include newlines, as long as the number of chars in the
+    blocks is less that a line length. To avoid this awkward situation,
+    we attach a big virtual size to [fnl] newlines. *)
+
+let fnl () = stras (1000000,"") ++ fnl ()
+
+let fnl2 () = fnl () ++ fnl ()
+
+let space_if = function true -> str " " | false -> mt ()
+
+let is_digit = function
+  | '0'..'9' -> true
+  | _ -> false
+
+let begins_with_CoqXX s =
+  let n = String.length s in
+  n >= 4 && s.[0] = 'C' && s.[1] = 'o' && s.[2] = 'q' &&
+  let i = ref 3 in
+  try while !i < n do
+    if s.[!i] = '_' then i:=n (*Stop*)
+    else if is_digit s.[!i] then incr i
+    else raise Not_found
+  done; true
+  with Not_found -> false
+
+let unquote s =
+  if lang () <> Scheme then s
+  else
+    let s = String.copy s in
+    for i=0 to String.length s - 1 do if s.[i] = '\'' then s.[i] <- '~' done;
+    s
+
+let rec qualify delim = function
+  | [] -> assert false
+  | [s] -> s
+  | ""::l -> qualify delim l
+  | s::l -> s^delim^(qualify delim l)
+
+let dottify = qualify "."
+let pseudo_qualify = qualify "__"
+
+(*s Uppercase/lowercase renamings. *)
+
+let is_upper s = match s.[0] with 'A' .. 'Z' -> true | _ -> false
+let is_lower s = match s.[0] with 'a' .. 'z' | '_' -> true | _ -> false
+
+let lowercase_id id = id_of_string (String.uncapitalize (string_of_id id))
+let uppercase_id id =
+  let s = string_of_id id in
+  assert (s<>"");
+  if s.[0] = '_' then id_of_string ("Coq_"^s)
+  else id_of_string (String.capitalize s)
+
+type kind = Term | Type | Cons | Mod
+
+let upperkind = function
+  | Type -> lang () = Haskell
+  | Term -> false
+  | Cons | Mod -> true
+
+let kindcase_id k id =
+  if upperkind k then uppercase_id id else lowercase_id id
+
+(*s de Bruijn environments for programs *)
+
+type env = identifier list * Idset.t
+
+(*s Generic renaming issues for local variable names. *)
+
+let rec rename_id id avoid =
+  if Idset.mem id avoid then rename_id (lift_subscript id) avoid else id
+
+let rec rename_vars avoid = function
+  | [] ->
+      [], avoid
+  | id :: idl when id == dummy_name ->
+      (* we don't rename dummy binders *)
+      let (idl', avoid') = rename_vars avoid idl in
+      (id :: idl', avoid')
+  | id :: idl ->
+      let (idl, avoid) = rename_vars avoid idl in
+      let id = rename_id (lowercase_id id) avoid in
+      (id :: idl, Idset.add id avoid)
+
+let rename_tvars avoid l =
+  let rec rename avoid = function
+    | [] -> [],avoid
+    | id :: idl ->
+	let id = rename_id (lowercase_id id) avoid in
+	let idl, avoid = rename (Idset.add id avoid) idl in
+	(id :: idl, avoid) in
+  fst (rename avoid l)
+
+let push_vars ids (db,avoid) =
+  let ids',avoid' = rename_vars avoid ids in
+  ids', (ids' @ db, avoid')
+
+let get_db_name n (db,_) =
+  let id = List.nth db (pred n) in
+  if id = dummy_name then id_of_string "__" else id
+
+
+(*S Renamings of global objects. *)
+
+(*s Tables of global renamings *)
+
+let register_cleanup, do_cleanup =
+  let funs = ref [] in
+  (fun f -> funs:=f::!funs), (fun () -> List.iter (fun f -> f ()) !funs)
+
+type phase = Pre | Impl | Intf
+
+let set_phase, get_phase =
+  let ph = ref Impl in ((:=) ph), (fun () -> !ph)
+
+let set_keywords, get_keywords =
+  let k = ref Idset.empty in
+  ((:=) k), (fun () -> !k)
+
+let add_global_ids, get_global_ids =
+  let ids = ref Idset.empty in
+  register_cleanup (fun () -> ids := get_keywords ());
+  let add s = ids := Idset.add s !ids
+  and get () = !ids
+  in (add,get)
+
+let empty_env () = [], get_global_ids ()
+
+let mktable autoclean =
+  let h = Hashtbl.create 97 in
+  if autoclean then register_cleanup (fun () -> Hashtbl.clear h);
+  (Hashtbl.replace h, Hashtbl.find h, fun () -> Hashtbl.clear h)
+
+(* We might have built [global_reference] whose canonical part is
+   inaccurate. We must hence compare only the user part,
+   hence using a Hashtbl might be incorrect *)
+
+let mktable_ref autoclean =
+  let m = ref Refmap'.empty in
+  let clear () = m := Refmap'.empty in
+  if autoclean then register_cleanup clear;
+  (fun r v -> m := Refmap'.add r v !m), (fun r -> Refmap'.find r !m), clear
+
+(* A table recording objects in the first level of all MPfile *)
+
+let add_mpfiles_content,get_mpfiles_content,clear_mpfiles_content =
+  mktable false
+
+let get_mpfiles_content mp =
+  try get_mpfiles_content mp
+  with Not_found -> failwith "get_mpfiles_content"
+
+(*s The list of external modules that will be opened initially *)
+
+let mpfiles_add, mpfiles_mem, mpfiles_list, mpfiles_clear =
+  let m = ref MPset.empty in
+  let add mp = m:=MPset.add mp !m
+  and mem mp = MPset.mem mp !m
+  and list () = MPset.elements !m
+  and clear () = m:=MPset.empty
+  in
+  register_cleanup clear;
+  (add,mem,list,clear)
+
+(*s List of module parameters that we should alpha-rename *)
+
+let params_ren_add, params_ren_mem =
+  let m = ref MPset.empty in
+  let add mp = m:=MPset.add mp !m
+  and mem mp = MPset.mem mp !m
+  and clear () = m:=MPset.empty
+  in
+  register_cleanup clear;
+  (add,mem)
+
+(*s table indicating the visible horizon at a precise moment,
+    i.e. the stack of structures we are inside.
+
+  - The sequence of [mp] parts should have the following form:
+  a [MPfile] at the beginning, and then more and more [MPdot]
+  over this [MPfile], or [MPbound] when inside the type of a
+  module parameter.
+
+  - the [params] are the [MPbound] when [mp] is a functor,
+    the innermost [MPbound] coming first in the list.
+
+  - The [content] part is used to record all the names already
+  seen at this level.
+*)
+
+type visible_layer = { mp : module_path;
+		       params : module_path list;
+		       content : ((kind*string),label) Hashtbl.t }
+
+let pop_visible, push_visible, get_visible =
+  let vis = ref [] in
+  register_cleanup (fun () -> vis := []);
+  let pop () =
+    match !vis with
+      | [] -> assert false
+      | v :: vl ->
+	  vis := vl;
+	  (* we save the 1st-level-content of MPfile for later use *)
+	  if get_phase () = Impl && modular () && is_modfile v.mp
+	  then add_mpfiles_content v.mp v.content
+  and push mp mps =
+    vis := { mp = mp; params = mps; content = Hashtbl.create 97 } :: !vis
+  and get () = !vis
+  in (pop,push,get)
+
+let get_visible_mps () = List.map (function v -> v.mp) (get_visible ())
+let top_visible () = match get_visible () with [] -> assert false | v::_ -> v
+let top_visible_mp () = (top_visible ()).mp
+let add_visible ks l = Hashtbl.add (top_visible ()).content ks l
+
+(* table of local module wrappers used to provide non-ambiguous names *)
+
+let add_duplicate, check_duplicate =
+  let index = ref 0 and dups = ref Gmap.empty in
+  register_cleanup (fun () -> index := 0; dups := Gmap.empty);
+  let add mp l =
+     incr index;
+     let ren = "Coq__" ^ string_of_int (!index) in
+     dups := Gmap.add (mp,l) ren !dups
+  and check mp l = Gmap.find (mp, l) !dups
+  in (add,check)
+
+type reset_kind = AllButExternal | Everything
+
+let reset_renaming_tables flag =
+  do_cleanup ();
+  if flag = Everything then clear_mpfiles_content ()
+
+(*S Renaming functions *)
+
+(* This function creates from [id] a correct uppercase/lowercase identifier.
+   This is done by adding a [Coq_] or [coq_] prefix. To avoid potential clashes
+   with previous [Coq_id] variable, these prefixes are duplicated if already
+   existing. *)
+
+let modular_rename k id =
+  let s = string_of_id id in
+  let prefix,is_ok =
+    if lang () <> CoreErlang
+     then if upperkind k then "Coq_",is_upper else "coq_",is_lower
+     else "_",(fun x -> true)
+  in
+  if not (is_ok s) ||
+     (Idset.mem id (get_keywords ())) ||
+     (String.length s >= 4 && String.sub s 0 4 = prefix)
+  then prefix ^ s
+  else s
+
+(*s For monolithic extraction, first-level modules might have to be renamed
+    with unique numbers *)
+
+let modfstlev_rename =
+  let add_prefixes,get_prefixes,_ = mktable true in
+  fun l ->
+    let coqid = id_of_string "Coq" in
+    let id = id_of_label l in
+    try
+      let coqset = get_prefixes id in
+      let nextcoq = next_ident_away coqid coqset in
+      add_prefixes id (nextcoq::coqset);
+      (string_of_id nextcoq)^"_"^(string_of_id id)
+    with Not_found ->
+      let s = string_of_id id in
+      if is_lower s || begins_with_CoqXX s then
+	(add_prefixes id [coqid]; "Coq_"^s)
+      else
+	(add_prefixes id []; s)
+
+(*s Creating renaming for a [module_path] : first, the real function ... *)
+
+let rec mp_renaming_fun mp = match mp with
+  | _ when not (modular ()) && at_toplevel mp -> [""]
+  | MPdot (mp,l) ->
+      let lmp = mp_renaming mp in
+      if lmp = [""] then (modfstlev_rename l)::lmp
+      else (modular_rename Mod (id_of_label l))::lmp
+  | MPbound mbid ->
+      let s = modular_rename Mod (id_of_mbid mbid) in
+      if not (params_ren_mem mp) then [s]
+      else let i,_,_ = repr_mbid mbid in [s^"__"^string_of_int i]
+  | MPfile _ ->
+      assert (modular ()); (* see [at_toplevel] above *)
+      assert (get_phase () = Pre);
+      let current_mpfile = (list_last (get_visible ())).mp in
+      if mp <> current_mpfile then mpfiles_add mp;
+      [string_of_modfile mp]
+
+(* ... and its version using a cache *)
+
+and mp_renaming =
+  let add,get,_ = mktable true in
+  fun x ->
+    try if is_mp_bound (base_mp x) then raise Not_found; get x
+    with Not_found -> let y = mp_renaming_fun x in add x y; y
+
+(*s Renamings creation for a [global_reference]: we build its fully-qualified
+    name in a [string list] form (head is the short name). *)
+
+let ref_renaming_fun (k,r) =
+  let mp = modpath_of_r r in
+  let l = mp_renaming mp in
+  let l = if lang () <> Ocaml && not (modular ()) then [""] else l in
+  let s = let idg = safe_basename_of_global r
+          in if l = [""] (* this happens only at toplevel of the monolithic case *)
+              then let globs = Idset.elements (get_global_ids ()) in
+                   let id = next_ident_away (kindcase_id k idg) globs
+                   in string_of_id id
+              else modular_rename k idg
+  in add_global_ids (id_of_string s)
+   ; s::l
+
+(* Cached version of the last function *)
+
+let ref_renaming =
+  let add,get,_ = mktable_ref true in
+  fun ((k,r) as x) ->
+    try if is_mp_bound (base_mp (modpath_of_r r)) then raise Not_found; get r
+    with Not_found -> let y = ref_renaming_fun x in add r y; y
+
+(* [visible_clash mp0 (k,s)] checks if [mp0-s] of kind [k]
+   can be printed as [s] in the current context of visible
+   modules. More precisely, we check if there exists a
+   visible [mp] that contains [s].
+   The verification stops if we encounter [mp=mp0]. *)
+
+let rec clash mem mp0 ks = function
+  | [] -> false
+  | mp :: _ when mp = mp0 -> false
+  | mp :: _ when mem mp ks -> true
+  | _ :: mpl -> clash mem mp0 ks mpl
+
+let mpfiles_clash mp0 ks =
+  clash (fun mp -> Hashtbl.mem (get_mpfiles_content mp)) mp0 ks
+    (List.rev (mpfiles_list ()))
+
+let rec params_lookup mp0 ks = function
+  | [] -> false
+  | param :: _ when mp0 = param -> true
+  | param :: params ->
+      if ks = (Mod, List.hd (mp_renaming param)) then params_ren_add param;
+      params_lookup mp0 ks params
+
+let visible_clash mp0 ks =
+  let rec clash = function
+    | [] -> false
+    | v :: _ when v.mp = mp0 -> false
+    | v :: vis ->
+	let b = Hashtbl.mem v.content ks in
+	if b && not (is_mp_bound mp0) then true
+	else begin
+	  if b then params_ren_add mp0;
+	  if params_lookup mp0 ks v.params then false
+	  else clash vis
+	end
+  in clash (get_visible ())
+
+(* Same, but with verbose output (and mp0 shouldn't be a MPbound) *)
+
+let visible_clash_dbg mp0 ks =
+  let rec clash = function
+    | [] -> None
+    | v :: _ when v.mp = mp0 -> None
+    | v :: vis ->
+	try Some (v.mp,Hashtbl.find v.content ks)
+	with Not_found ->
+	  if params_lookup mp0 ks v.params then None
+	  else clash vis
+  in clash (get_visible ())
+
+(* After the 1st pass, we can decide which modules will be opened initially *)
+
+let opened_libraries () =
+  if not (modular ()) then []
+  else
+    let used_files = mpfiles_list () in
+    let used_ks = List.map (fun mp -> Mod,string_of_modfile mp) used_files in
+    (* By default, we open all used files. Ambiguities will be resolved later
+       by using qualified names. Nonetheless, we don't open any file A that
+       contains an immediate submodule A.B hiding another file B : otherwise,
+       after such an open, there's no unambiguous way to refer to objects of B. *)
+    let to_open =
+      List.filter
+	(fun mp ->
+	   not (List.exists (Hashtbl.mem (get_mpfiles_content mp)) used_ks))
+	used_files
+    in
+    mpfiles_clear ();
+    List.iter mpfiles_add to_open;
+    mpfiles_list ()
+
+(*s On-the-fly qualification issues for both monolithic or modular extraction. *)
+
+(* [pp_ocaml_gen] below is a function that factorize the printing of both
+   [global_reference] and module names for ocaml. When [k=Mod] then [olab=None],
+   otherwise it contains the label of the reference to print.
+   [rls] is the string list giving the qualified name, short name at the end. *)
+
+(* In Coq, we can qualify [M.t] even if we are inside [M], but in Ocaml we
+   cannot do that. So, if [t] gets hidden and we need a long name for it,
+   we duplicate the _definition_ of t in a Coq__XXX module, and similarly
+   for a sub-module [M.N] *)
+
+let pp_duplicate k' prefix mp rls olab =
+  let rls', lbl =
+    if k'<>Mod then
+      (* Here rls=[s], the ref to print is <prefix>.<s>, and olab<>None *)
+      rls, Option.get olab
+    else
+      (* Here rls=s::rls', we search the label for s inside mp *)
+      List.tl rls, get_nth_label_mp (mp_length mp - mp_length prefix) mp
+  in
+  try dottify (check_duplicate prefix lbl :: rls')
+  with Not_found ->
+    assert (get_phase () = Pre); (* otherwise it's too late *)
+    add_duplicate prefix lbl; dottify rls
+
+let fstlev_ks k = function
+  | [] -> assert false
+  | [s] -> k,s
+  | s::_ -> Mod,s
+
+(* [pp_ocaml_local] : [mp] has something in common with [top_visible ()]
+   but isn't equal to it *)
+
+let pp_ocaml_local k prefix mp rls olab =
+  (* what is the largest prefix of [mp] that belongs to [visible]? *)
+  assert (k <> Mod || mp <> prefix); (* mp as whole module isn't in itself *)
+  let rls' = list_skipn (mp_length prefix) rls in
+  let k's = fstlev_ks k rls' in
+  (* Reference r / module path mp is of the form [<prefix>.s.<...>]. *)
+  if not (visible_clash prefix k's) then dottify rls'
+  else pp_duplicate (fst k's) prefix mp rls' olab
+
+(* [pp_ocaml_bound] : [mp] starts with a [MPbound], and we are not inside
+   (i.e. we are not printing the type of the module parameter) *)
+
+let pp_ocaml_bound base rls =
+  (* clash with a MPbound will be detected and fixed by renaming this MPbound *)
+  if get_phase () = Pre then ignore (visible_clash base (Mod,List.hd rls));
+  dottify rls
+
+(* [pp_ocaml_extern] : [mp] isn't local, it is defined in another [MPfile]. *)
+
+let pp_ocaml_extern k base rls = match rls with
+  | [] -> assert false
+  | base_s :: rls' ->
+      if (not (modular ())) (* Pseudo qualification with "" *)
+	|| (rls' = [])  (* Case of a file A.v used as a module later *)
+	|| (not (mpfiles_mem base)) (* Module not opened *)
+	|| (mpfiles_clash base (fstlev_ks k rls')) (* Conflict in opened files *)
+	|| (visible_clash base (fstlev_ks k rls')) (* Local conflict *)
+      then
+	(* We need to fully qualify. Last clash situation is unsupported *)
+	match visible_clash_dbg base (Mod,base_s) with
+	  | None -> dottify rls
+	  | Some (mp,l) -> error_module_clash base (MPdot (mp,l))
+      else
+	(* Standard situation : object in an opened file *)
+	dottify rls'
+
+(* [pp_ocaml_gen] : choosing between [pp_ocaml_extern] or [pp_ocaml_extern] *)
+
+let pp_ocaml_gen k mp rls olab =
+  match common_prefix_from_list mp (get_visible_mps ()) with
+    | Some prefix -> pp_ocaml_local k prefix mp rls olab
+    | None ->
+	let base = base_mp mp in
+	if is_mp_bound base then pp_ocaml_bound base rls
+	else pp_ocaml_extern k base rls
+
+(* For Haskell, things are simplier: we have removed (almost) all structures *)
+
+let pp_haskell_gen k mp rls = match rls with
+  | [] -> assert false
+  | s::rls' ->
+    let str = pseudo_qualify rls' in
+    let str = if is_upper str && not (upperkind k) then ("_"^str) else str in
+    let prf = if base_mp mp <> top_visible_mp () then s ^ "." else "" in
+    prf ^ str
+
+(* For Core Erlang, we guess this will works *)
+let rec dequalify = function
+  | [] -> assert false
+  | [s] -> s
+  | s::rls' -> dequalify rls'
+
+let pp_coreerlang_gen k mp rls =
+  match k with
+    | Cons -> dequalify rls
+    | x -> 
+      match rls with
+        | [] -> assert false
+        | s::rls' ->
+           let str = dottify rls' in
+           let prf = if base_mp mp <> top_visible_mp () then s ^ "." else ""
+           in prf ^ str
+
+
+(* Main name printing function for a reference *)
+
+let pp_global k r =
+  let ls = ref_renaming (k,r) in
+  assert (List.length ls > 1);
+  let s = List.hd ls in
+  let mp,_,l = repr_of_r r in
+  if mp = top_visible_mp () then
+    (* simpliest situation: definition of r (or use in the same context) *)
+    (* we update the visible environment *)
+    (add_visible (k,s) l; unquote s)
+  else
+    let rls = List.rev ls in (* for what come next it's easier this way *)
+    match lang () with
+      | Scheme -> unquote s (* no modular Scheme extraction... *)
+      | Haskell -> if modular () then pp_haskell_gen k mp rls else s
+      | CoreErlang -> if modular () then pp_coreerlang_gen k mp rls else s
+      | Ocaml -> pp_ocaml_gen k mp rls (Some l)
+
+(* The next function is used only in Ocaml extraction...*)
+
+let pp_module mp =
+  let ls = mp_renaming mp in
+  match mp with
+    | MPdot (mp0,l) when mp0 = top_visible_mp () ->
+	(* simpliest situation: definition of mp (or use in the same context) *)
+	(* we update the visible environment *)
+	let s = List.hd ls in
+	add_visible (Mod,s) l; s
+    | _ -> pp_ocaml_gen Mod mp (List.rev ls) None
+
+(** Special hack for constants of type Ascii.ascii : if an
+    [Extract Inductive ascii => char] has been declared, then
+    the constants are directly turned into chars *)
+
+let mk_ind path s =
+  make_mind (MPfile (dirpath_of_string path)) empty_dirpath (mk_label s)
+
+let ind_ascii = mk_ind "Coq.Strings.Ascii" "ascii"
+
+let check_extract_ascii () =
+  try
+    let char_type = match lang () with
+      | Ocaml -> "char"
+      | Haskell -> "Char"
+      | CoreErlang -> "char"
+      | _ -> raise Not_found
+    in
+    find_custom (IndRef (ind_ascii,0)) = char_type
+  with Not_found -> false
+
+let is_list_cons l =
+ List.for_all (function MLcons (_,ConstructRef(_,_),[]) -> true | _ -> false) l
+
+let is_native_char = function
+  | MLcons(_,ConstructRef ((kn,0),1),l) ->
+    kn = ind_ascii && check_extract_ascii () && is_list_cons l
+  | _ -> false
+
+let pp_native_char c =
+  let rec cumul = function
+    | [] -> 0
+    | MLcons(_,ConstructRef(_,j),[])::l -> (2-j) + 2 * (cumul l)
+    | _ -> assert false
+  in
+  let l = match c with MLcons(_,_,l) -> l | _ -> assert false in
+  str ("'"^Char.escaped (Char.chr (cumul l))^"'")
diff -aurN coq-8.4pl2-pristine/plugins/extraction/coreerlang.ml coq-8.4pl2-new/plugins/extraction/coreerlang.ml
--- coq-8.4pl2-pristine/plugins/extraction/coreerlang.ml	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/coreerlang.ml	2013-07-15 08:44:39.412126738 -0700
@@ -0,0 +1,1324 @@
+open Pp
+open Util
+open Names
+open Libnames
+open Miniml
+open Mlutil
+open Common
+open Table
+open Str
+
+(** val length : 'a1 list -> int **)
+
+let rec length = function
+| [] -> 0
+| y :: l' -> succ (length l')
+
+(** val app : 'a1 list -> 'a1 list -> 'a1 list **)
+
+let rec app l m =
+  match l with
+  | [] -> m
+  | a :: l1 -> a :: (app l1 m)
+
+type ('a, 'p) sigT =
+| ExistT of 'a * 'p
+
+(** val projT1 : ('a1, 'a2) sigT -> 'a1 **)
+
+let projT1 = function
+| ExistT (a, p) -> a
+
+(** val projT2 : ('a1, 'a2) sigT -> 'a2 **)
+
+let projT2 = function
+| ExistT (x0, h) -> h
+
+(** val plus : int -> int -> int **)
+
+let rec plus = (+)
+
+(** val rev : 'a1 list -> 'a1 list **)
+
+let rec rev = function
+| [] -> []
+| x :: l' -> app (rev l') (x :: [])
+
+(** val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list **)
+
+let rec map f = function
+| [] -> []
+| a :: t -> (f a) :: (map f t)
+
+(** val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1 **)
+
+let rec fold_right f a0 = function
+| [] -> a0
+| b :: t -> f b (fold_right f a0 t)
+
+(** val int_of_nat : int -> int **)
+
+let int_of_nat =
+  let rec loop acc n =
+    (fun fO fS n -> if n=0 then fO () else fS (n-1))
+      (fun _ ->
+      acc)
+      (fun n0 ->
+      loop (succ acc) n0)
+      n
+  in loop 0
+
+module CoreErlang = 
+ struct 
+  type atom_t =
+    string
+    (* singleton inductive, whose constructor was mk_atom *)
+  
+  (** val atom_t_rect : (string -> 'a1) -> atom_t -> 'a1 **)
+  
+  let atom_t_rect f a =
+    f a
+  
+  (** val atom_t_rec : (string -> 'a1) -> atom_t -> 'a1 **)
+  
+  let atom_t_rec f a =
+    f a
+  
+  (** val atom_eq_dec_obligation_1 :
+      atom_t -> char list -> string -> bool **)
+  
+  let atom_eq_dec_obligation_1 a s s' =
+    true
+  
+  (** val atom_eq_dec_obligation_2 :
+      atom_t -> char list -> string -> bool **)
+  
+  let atom_eq_dec_obligation_2 a s s' =
+    false
+  
+  (** val atom_eq_dec : atom_t -> char list -> bool **)
+  
+  let atom_eq_dec a s =
+    if (function a -> function b -> a = b) a
+         ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+           s)
+    then atom_eq_dec_obligation_1 a s a
+    else atom_eq_dec_obligation_2 a s a
+  
+  type integer_t = int
+  
+  type char_t = char
+  
+  type module_t =
+  | Coq_module of atom_t * fname_t list * attr_t list * def_t list
+  and fname_t =
+  | Coq_fname of atom_t * int
+  and attr_t =
+  | Coq_attr of atom_t * const_t
+  and const_t =
+  | Coq_const of lit_t * const_t list
+  and lit_t =
+  | Coq_lit_int of integer_t
+  | Coq_lit_atom of atom_t
+  | Coq_lit_char of char_t
+  | Coq_lit_str of string
+  | Coq_lit_nil
+  | Coq_lit_cons of atom_t
+  | Coq_lit_tup
+  and def_t =
+  | Coq_def of fname_t * fun_t
+  | Coq_def_custom of string * string
+  and fun_t =
+  | Coq_func of var_t list * term_t
+  and var_t =
+  | Coq_var of string
+  | Coq_var_atom of string
+  and term_t =
+  | Coq_term_var of var_t
+  | Coq_term_fname of fname_t
+  | Coq_term_lit of lit_t * term_t list
+  | Coq_term_fun of fun_t
+  | Coq_term_let of var_t * term_t * term_t
+  | Coq_term_case of term_t * clause_t list
+  | Coq_term_letrec of def_t list * term_t
+  | Coq_term_apply of term_t * term_t list
+  | Coq_term_call of term_t * term_t * term_t list
+  | Coq_term_primop of atom_t * term_t list
+  | Coq_term_try of term_t * var_t list * term_t * var_t list * term_t
+  | Coq_term_recv of clause_t list * term_t * term_t
+  | Coq_term_do of term_t * term_t
+  | Coq_term_catch of term_t
+  | Coq_term_globl of atom_t
+  | Coq_term_custom of string
+  and clause_t =
+  | Coq_clause of pat_t * term_t * term_t
+  and pat_t =
+  | Coq_pat_var of var_t
+  | Coq_pat_lit of lit_t * pat_t list
+  | Coq_pat_alias of var_t * pat_t
+  
+  (** val module_t_rect :
+      (atom_t -> fname_t list -> attr_t list -> def_t list -> 'a1) ->
+      module_t -> 'a1 **)
+  
+  let module_t_rect f = function
+  | Coq_module (x, x0, x1, x2) -> f x x0 x1 x2
+  
+  (** val module_t_rec :
+      (atom_t -> fname_t list -> attr_t list -> def_t list -> 'a1) ->
+      module_t -> 'a1 **)
+  
+  let module_t_rec f = function
+  | Coq_module (x, x0, x1, x2) -> f x x0 x1 x2
+  
+  (** val fname_t_rect : (atom_t -> int -> 'a1) -> fname_t -> 'a1 **)
+  
+  let fname_t_rect f = function
+  | Coq_fname (x, x0) -> f x x0
+  
+  (** val fname_t_rec : (atom_t -> int -> 'a1) -> fname_t -> 'a1 **)
+  
+  let fname_t_rec f = function
+  | Coq_fname (x, x0) -> f x x0
+  
+  (** val attr_t_rect : (atom_t -> const_t -> 'a1) -> attr_t -> 'a1 **)
+  
+  let attr_t_rect f = function
+  | Coq_attr (x, x0) -> f x x0
+  
+  (** val attr_t_rec : (atom_t -> const_t -> 'a1) -> attr_t -> 'a1 **)
+  
+  let attr_t_rec f = function
+  | Coq_attr (x, x0) -> f x x0
+  
+  (** val const_t_rect : (lit_t -> const_t list -> 'a1) -> const_t -> 'a1 **)
+  
+  let const_t_rect f = function
+  | Coq_const (x, x0) -> f x x0
+  
+  (** val const_t_rec : (lit_t -> const_t list -> 'a1) -> const_t -> 'a1 **)
+  
+  let const_t_rec f = function
+  | Coq_const (x, x0) -> f x x0
+  
+  (** val lit_t_rect :
+      (integer_t -> 'a1) -> (atom_t -> 'a1) -> (char_t -> 'a1) -> (string ->
+      'a1) -> 'a1 -> (atom_t -> 'a1) -> 'a1 -> lit_t -> 'a1 **)
+  
+  let lit_t_rect f f0 f1 f2 f3 f4 f5 = function
+  | Coq_lit_int x -> f x
+  | Coq_lit_atom x -> f0 x
+  | Coq_lit_char x -> f1 x
+  | Coq_lit_str x -> f2 x
+  | Coq_lit_nil -> f3
+  | Coq_lit_cons x -> f4 x
+  | Coq_lit_tup -> f5
+  
+  (** val lit_t_rec :
+      (integer_t -> 'a1) -> (atom_t -> 'a1) -> (char_t -> 'a1) -> (string ->
+      'a1) -> 'a1 -> (atom_t -> 'a1) -> 'a1 -> lit_t -> 'a1 **)
+  
+  let lit_t_rec f f0 f1 f2 f3 f4 f5 = function
+  | Coq_lit_int x -> f x
+  | Coq_lit_atom x -> f0 x
+  | Coq_lit_char x -> f1 x
+  | Coq_lit_str x -> f2 x
+  | Coq_lit_nil -> f3
+  | Coq_lit_cons x -> f4 x
+  | Coq_lit_tup -> f5
+  
+  (** val def_t_rect :
+      (fname_t -> fun_t -> 'a1) -> (string -> string -> 'a1) -> def_t -> 'a1 **)
+  
+  let def_t_rect f f0 = function
+  | Coq_def (x, x0) -> f x x0
+  | Coq_def_custom (x, x0) -> f0 x x0
+  
+  (** val def_t_rec :
+      (fname_t -> fun_t -> 'a1) -> (string -> string -> 'a1) -> def_t -> 'a1 **)
+  
+  let def_t_rec f f0 = function
+  | Coq_def (x, x0) -> f x x0
+  | Coq_def_custom (x, x0) -> f0 x x0
+  
+  (** val fun_t_rect : (var_t list -> term_t -> 'a1) -> fun_t -> 'a1 **)
+  
+  let fun_t_rect f = function
+  | Coq_func (x, x0) -> f x x0
+  
+  (** val fun_t_rec : (var_t list -> term_t -> 'a1) -> fun_t -> 'a1 **)
+  
+  let fun_t_rec f = function
+  | Coq_func (x, x0) -> f x x0
+  
+  (** val var_t_rect : (string -> 'a1) -> (string -> 'a1) -> var_t -> 'a1 **)
+  
+  let var_t_rect f f0 = function
+  | Coq_var x -> f x
+  | Coq_var_atom x -> f0 x
+  
+  (** val var_t_rec : (string -> 'a1) -> (string -> 'a1) -> var_t -> 'a1 **)
+  
+  let var_t_rec f f0 = function
+  | Coq_var x -> f x
+  | Coq_var_atom x -> f0 x
+  
+  (** val term_t_rect :
+      (var_t -> 'a1) -> (fname_t -> 'a1) -> (lit_t -> term_t list -> 'a1) ->
+      (fun_t -> 'a1) -> (var_t -> term_t -> 'a1 -> term_t -> 'a1 -> 'a1) ->
+      (term_t -> 'a1 -> clause_t list -> 'a1) -> (def_t list -> term_t -> 'a1
+      -> 'a1) -> (term_t -> 'a1 -> term_t list -> 'a1) -> (term_t -> 'a1 ->
+      term_t -> 'a1 -> term_t list -> 'a1) -> (atom_t -> term_t list -> 'a1)
+      -> (term_t -> 'a1 -> var_t list -> term_t -> 'a1 -> var_t list ->
+      term_t -> 'a1 -> 'a1) -> (clause_t list -> term_t -> 'a1 -> term_t ->
+      'a1 -> 'a1) -> (term_t -> 'a1 -> term_t -> 'a1 -> 'a1) -> (term_t ->
+      'a1 -> 'a1) -> (atom_t -> 'a1) -> (string -> 'a1) -> term_t -> 'a1 **)
+  
+  let rec term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 = function
+  | Coq_term_var v -> f v
+  | Coq_term_fname f15 -> f0 f15
+  | Coq_term_lit (l, l0) -> f1 l l0
+  | Coq_term_fun f15 -> f2 f15
+  | Coq_term_let (v, t0, t1) ->
+    f3 v t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_case (t0, l) ->
+    f4 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) l
+  | Coq_term_letrec (l, t0) ->
+    f5 l t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+  | Coq_term_apply (t0, l) ->
+    f6 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) l
+  | Coq_term_call (t0, t1, l) ->
+    f7 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1) l
+  | Coq_term_primop (a, l) -> f8 a l
+  | Coq_term_try (t0, l, t1, l0, t2) ->
+    f9 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) l
+      t1 (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+      l0 t2
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t2)
+  | Coq_term_recv (l, t0, t1) ->
+    f10 l t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_do (t0, t1) ->
+    f11 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_catch t0 ->
+    f12 t0
+      (term_t_rect f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+  | Coq_term_globl a -> f13 a
+  | Coq_term_custom c -> f14 c
+  
+  (** val term_t_rec :
+      (var_t -> 'a1) -> (fname_t -> 'a1) -> (lit_t -> term_t list -> 'a1) ->
+      (fun_t -> 'a1) -> (var_t -> term_t -> 'a1 -> term_t -> 'a1 -> 'a1) ->
+      (term_t -> 'a1 -> clause_t list -> 'a1) -> (def_t list -> term_t -> 'a1
+      -> 'a1) -> (term_t -> 'a1 -> term_t list -> 'a1) -> (term_t -> 'a1 ->
+      term_t -> 'a1 -> term_t list -> 'a1) -> (atom_t -> term_t list -> 'a1)
+      -> (term_t -> 'a1 -> var_t list -> term_t -> 'a1 -> var_t list ->
+      term_t -> 'a1 -> 'a1) -> (clause_t list -> term_t -> 'a1 -> term_t ->
+      'a1 -> 'a1) -> (term_t -> 'a1 -> term_t -> 'a1 -> 'a1) -> (term_t ->
+      'a1 -> 'a1) -> (atom_t -> 'a1) -> (string -> 'a1) -> term_t -> 'a1 **)
+  
+  let rec term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 = function
+  | Coq_term_var v -> f v
+  | Coq_term_fname f15 -> f0 f15
+  | Coq_term_lit (l, l0) -> f1 l l0
+  | Coq_term_fun f15 -> f2 f15
+  | Coq_term_let (v, t0, t1) ->
+    f3 v t0
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_case (t0, l) ->
+    f4 t0 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+      l
+  | Coq_term_letrec (l, t0) ->
+    f5 l t0
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+  | Coq_term_apply (t0, l) ->
+    f6 t0 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+      l
+  | Coq_term_call (t0, t1, l) ->
+    f7 t0 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+      t1 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+      l
+  | Coq_term_primop (a, l) -> f8 a l
+  | Coq_term_try (t0, l, t1, l0, t2) ->
+    f9 t0 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+      l t1
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1) l0
+      t2 (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t2)
+  | Coq_term_recv (l, t0, t1) ->
+    f10 l t0
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_do (t0, t1) ->
+    f11 t0
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0) t1
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t1)
+  | Coq_term_catch t0 ->
+    f12 t0
+      (term_t_rec f f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 t0)
+  | Coq_term_globl a -> f13 a
+  | Coq_term_custom c -> f14 c
+  
+  (** val clause_t_rect :
+      (pat_t -> term_t -> term_t -> 'a1) -> clause_t -> 'a1 **)
+  
+  let clause_t_rect f = function
+  | Coq_clause (x, x0, x1) -> f x x0 x1
+  
+  (** val clause_t_rec :
+      (pat_t -> term_t -> term_t -> 'a1) -> clause_t -> 'a1 **)
+  
+  let clause_t_rec f = function
+  | Coq_clause (x, x0, x1) -> f x x0 x1
+  
+  (** val pat_t_rect :
+      (var_t -> 'a1) -> (lit_t -> pat_t list -> 'a1) -> (var_t -> pat_t ->
+      'a1 -> 'a1) -> pat_t -> 'a1 **)
+  
+  let rec pat_t_rect f f0 f1 = function
+  | Coq_pat_var v -> f v
+  | Coq_pat_lit (l, l0) -> f0 l l0
+  | Coq_pat_alias (v, p0) -> f1 v p0 (pat_t_rect f f0 f1 p0)
+  
+  (** val pat_t_rec :
+      (var_t -> 'a1) -> (lit_t -> pat_t list -> 'a1) -> (var_t -> pat_t ->
+      'a1 -> 'a1) -> pat_t -> 'a1 **)
+  
+  let rec pat_t_rec f f0 f1 = function
+  | Coq_pat_var v -> f v
+  | Coq_pat_lit (l, l0) -> f0 l l0
+  | Coq_pat_alias (v, p0) -> f1 v p0 (pat_t_rec f f0 f1 p0)
+ end
+
+(** val pp_global : Kind -> Libnames.global_reference -> string **)
+
+let pp_global k r =
+  if is_inline_custom r then find_custom r else pp_global k r
+
+(** val mk_idset : char list list -> idset **)
+
+let mk_idset ss =
+  fold_right (fun s ->
+    Idset.add
+      (id_of_string
+        ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+          s))) Idset.empty ss
+
+(** val keywords0 : idset **)
+
+let keywords0 =
+  mk_idset
+    (('a'::('f'::('t'::('e'::('r'::[]))))) :: (('a'::('p'::('p'::('l'::('y'::[]))))) :: (('a'::('t'::('t'::('r'::('i'::('b'::('u'::('t'::('e'::('s'::[])))))))))) :: (('c'::('a'::('l'::('l'::[])))) :: (('c'::('a'::('s'::('e'::[])))) :: (('c'::('a'::('t'::('c'::('h'::[]))))) :: (('d'::('o'::[])) :: (('e'::('n'::('d'::[]))) :: (('f'::('u'::('n'::[]))) :: (('i'::('n'::[])) :: (('l'::('e'::('t'::[]))) :: (('l'::('e'::('t'::('r'::('e'::('c'::[])))))) :: (('m'::('o'::('d'::('u'::('l'::('e'::[])))))) :: (('o'::('f'::[])) :: (('p'::('r'::('i'::('m'::('o'::('p'::[])))))) :: (('r'::('e'::('c'::('e'::('i'::('v'::('e'::[]))))))) :: (('t'::('r'::('y'::[]))) :: (('w'::('h'::('e'::('n'::[])))) :: (('_'::('w'::('c'::[]))) :: [])))))))))))))))))))
+
+(** val file_suffix0 : string **)
+
+let file_suffix0 =
+  (function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+    ('.'::('c'::('o'::('r'::('e'::[])))))
+
+(** val sig_suffix0 : string option **)
+
+let sig_suffix0 =
+  Some
+    ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+      ('.'::('h'::('r'::('l'::[])))))
+
+(** val map2 : ('a1 -> 'a2 -> 'a3) -> 'a1 list -> 'a2 list -> 'a3 list **)
+
+let rec map2 f xs ys =
+  match xs with
+  | [] -> []
+  | x :: xs' ->
+    (match ys with
+     | [] -> []
+     | y :: ys' -> (f x y) :: (map2 f xs' ys'))
+
+(** val map3 :
+    ('a1 -> 'a2 -> 'a3 -> 'a4) -> 'a1 list -> 'a2 list -> 'a3 list -> 'a4
+    list **)
+
+let rec map3 f xs ys zs =
+  match xs with
+  | [] -> []
+  | x :: xs' ->
+    (match ys with
+     | [] -> []
+     | y :: ys' ->
+       (match zs with
+        | [] -> []
+        | z :: zs' -> (f x y z) :: (map3 f xs' ys' zs')))
+
+(** val extr_pat :
+    Common.env -> Miniml.ml_pattern -> Names.identifier list ->
+    CoreErlang.pat_t **)
+
+let rec extr_pat e p ids =
+  match p with
+  | Miniml.Pcons (r, xs) ->
+    CoreErlang.Coq_pat_lit ((CoreErlang.Coq_lit_cons (pp_global Cons r)),
+      (map (fun x -> extr_pat e x ids) xs))
+  | Miniml.Ptuple xs ->
+    CoreErlang.Coq_pat_lit (CoreErlang.Coq_lit_tup,
+      (map (fun x -> extr_pat e x ids) xs))
+  | Miniml.Prel k ->
+    CoreErlang.Coq_pat_var (CoreErlang.Coq_var
+      (string_of_id (get_db_name k e)))
+  | Miniml.Pwild ->
+    CoreErlang.Coq_pat_var (CoreErlang.Coq_var
+      ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+        ('_'::('w'::('c'::[])))))
+  | Miniml.Pusual k ->
+    CoreErlang.Coq_pat_lit ((CoreErlang.Coq_lit_cons (pp_global Cons k)),
+      (map (fun i -> CoreErlang.Coq_pat_var (CoreErlang.Coq_var
+        (string_of_id i))) ids))
+
+(** val extr_ast_func :
+    (Common.env, Miniml.ml_ast) sigT -> CoreErlang.term_t **)
+
+let rec extr_ast_func x =
+  let e = projT1 x in
+  let t = projT2 x in
+  let extr_ast0 = fun e0 t0 -> let y = ExistT (e0, t0) in extr_ast_func y in
+  (match t with
+   | Miniml.MLrel k ->
+     CoreErlang.Coq_term_var (CoreErlang.Coq_var
+       (string_of_id (get_db_name k e)))
+   | Miniml.MLapp (f, xs) ->
+     (match f with
+      | Miniml.MLglob r ->
+        let r_modpath = string_of_mp (modpath_of_r r) in
+        let r' = pp_global Term r in
+        let filtered_var =
+          Str.split
+            (Str.regexp
+              ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+                ('['::('~'::(']'::[]))))) r'
+        in
+        (match filtered_var with
+         | [] ->
+           CoreErlang.Coq_term_call ((CoreErlang.Coq_term_globl r_modpath),
+             (CoreErlang.Coq_term_globl r'),
+             (map (fun x0 -> extr_ast0 e x0) xs))
+         | m :: l ->
+           (match l with
+            | [] ->
+              CoreErlang.Coq_term_call ((CoreErlang.Coq_term_globl
+                r_modpath), (CoreErlang.Coq_term_globl r'),
+                (map (fun x0 -> extr_ast0 e x0) xs))
+            | f0 :: l0 ->
+              (match l0 with
+               | [] ->
+                 CoreErlang.Coq_term_call ((CoreErlang.Coq_term_globl m),
+                   (CoreErlang.Coq_term_globl f0),
+                   (map (fun x0 -> extr_ast0 e x0) xs))
+               | c :: l1 ->
+                 CoreErlang.Coq_term_call ((CoreErlang.Coq_term_globl
+                   r_modpath), (CoreErlang.Coq_term_globl r'),
+                   (map (fun x0 -> extr_ast0 e x0) xs)))))
+      | x0 ->
+        let f' = extr_ast0 e x0 in
+        (match f' with
+         | CoreErlang.Coq_term_letrec (defs, t0) ->
+           (match t0 with
+            | CoreErlang.Coq_term_var v ->
+              CoreErlang.Coq_term_letrec (defs, (CoreErlang.Coq_term_apply
+                ((CoreErlang.Coq_term_var v),
+                (map (fun x1 -> extr_ast0 e x1) xs))))
+            | x1 ->
+              CoreErlang.Coq_term_apply (f',
+                (map (fun x2 -> extr_ast0 e x2) xs)))
+         | x1 ->
+           CoreErlang.Coq_term_apply (f',
+             (map (fun x2 -> extr_ast0 e x2) xs))))
+   | Miniml.MLlam (wildcard', wildcard'0) ->
+     let (bl, t') = collect_lams t in
+     let (bl', e') = push_vars (map id_of_mlid bl) e in
+     CoreErlang.Coq_term_fun (CoreErlang.Coq_func
+     ((map (fun s -> CoreErlang.Coq_var (string_of_id s)) (rev bl')),
+     (extr_ast0 e' t')))
+   | Miniml.MLletin (v, e1, e2) ->
+     let (bl, e') = push_vars ((id_of_mlid v) :: []) e in
+     (match bl with
+      | [] -> assert false (* absurd case *)
+      | v' :: l ->
+        (match l with
+         | [] ->
+           let e1' = extr_ast0 e e1 in
+           let e2' = extr_ast0 e' e2 in
+           CoreErlang.Coq_term_let ((CoreErlang.Coq_var (string_of_id v')),
+           e1', e2')
+         | i :: l0 -> assert false (* absurd case *)))
+   | Miniml.MLglob r ->
+     let r' = pp_global Term r in
+     if is_inline_custom r
+     then CoreErlang.Coq_term_custom r'
+     else CoreErlang.Coq_term_globl r'
+   | Miniml.MLcons (wildcard', r, xs) ->
+     CoreErlang.Coq_term_lit ((CoreErlang.Coq_lit_cons (pp_global Cons r)),
+       (map (fun x0 -> extr_ast0 e x0) xs))
+   | Miniml.MLtuple xs ->
+     CoreErlang.Coq_term_lit (CoreErlang.Coq_lit_tup,
+       (map (fun x0 -> extr_ast0 e x0) xs))
+   | Miniml.MLcase (wildcard', t', br) ->
+     let extr_branch = fun b ->
+       let (ids, p, t'0) = b in
+       let (ids', e') = push_vars (map id_of_mlid ids) e in
+       CoreErlang.Coq_clause ((extr_pat e' p (rev ids')),
+       (CoreErlang.Coq_term_lit ((CoreErlang.Coq_lit_atom
+       ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+         ('t'::('r'::('u'::('e'::[])))))), [])), (extr_ast0 e' t'0))
+     in
+     let t'' = extr_ast0 e t' in
+     let clauses = Array.to_list (Array.map extr_branch br) in
+     let as_case = CoreErlang.Coq_term_case (t'', clauses) in
+     (match t'' with
+      | CoreErlang.Coq_term_apply (t0, l) ->
+        (match t0 with
+         | CoreErlang.Coq_term_fname f ->
+           let CoreErlang.Coq_fname (a, n) = f in
+           ((fun fO fS n -> if n=0 then fO () else fS (n-1))
+              (fun _ ->
+              as_case)
+              (fun n0 ->
+              (fun fO fS n -> if n=0 then fO () else fS (n-1))
+                (fun _ ->
+                as_case)
+                (fun n1 ->
+                (fun fO fS n -> if n=0 then fO () else fS (n-1))
+                  (fun _ ->
+                  match l with
+                  | [] -> as_case
+                  | delay :: l0 ->
+                    (match l0 with
+                     | [] -> as_case
+                     | default :: l1 ->
+                       (match l1 with
+                        | [] ->
+                          if CoreErlang.atom_eq_dec a
+                               ('r'::('e'::('c'::('e'::('i'::('v'::('e'::('_'::('f'::('i'::('n'::[])))))))))))
+                          then CoreErlang.Coq_term_recv (clauses, delay,
+                                 default)
+                          else as_case
+                        | t1 :: l2 -> as_case)))
+                  (fun n2 ->
+                  as_case)
+                  n1)
+                n0)
+              n)
+         | x0 -> as_case)
+      | x0 -> as_case)
+   | Miniml.MLfix (k, ids, fns) ->
+     let (ids', e') = push_vars (rev (Array.to_list ids)) e in
+     let zip = fun n f ->
+       let n' = string_of_id n in
+       let (vs, f') = collect_lams f in
+       let (vs', e'') = push_vars (map id_of_mlid vs) e' in
+       let f'' = extr_ast0 e'' f' in
+       CoreErlang.Coq_def ((CoreErlang.Coq_fname (n', (length vs'))),
+       (CoreErlang.Coq_func
+       ((rev (map (fun v -> CoreErlang.Coq_var (string_of_id v)) vs')),
+       f'')))
+     in
+     let defs = map2 zip (rev ids') (Array.to_list fns) in
+     let id =
+       (function x -> function i -> x.(i)) (Array.of_list (rev ids'))
+         (int_of_nat k)
+     in
+     CoreErlang.Coq_term_letrec (defs, (CoreErlang.Coq_term_var
+     (CoreErlang.Coq_var_atom (string_of_id id))))
+   | Miniml.MLexn s ->
+     CoreErlang.Coq_term_primop
+       (((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+          ('r'::('a'::('i'::('s'::('e'::[])))))), ((CoreErlang.Coq_term_lit
+       ((CoreErlang.Coq_lit_atom
+       ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+         ('e'::('r'::('r'::('o'::('r'::[]))))))),
+       [])) :: ((CoreErlang.Coq_term_lit ((CoreErlang.Coq_lit_str s),
+       [])) :: [])))
+   | Miniml.MLdummy ->
+     CoreErlang.Coq_term_lit ((CoreErlang.Coq_lit_atom
+       ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+         ('d'::('u'::('m'::('m'::('y'::[]))))))), [])
+   | Miniml.MLaxiom ->
+     CoreErlang.Coq_term_primop
+       (((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+          ('r'::('a'::('i'::('s'::('e'::[])))))), ((CoreErlang.Coq_term_lit
+       ((CoreErlang.Coq_lit_atom
+       ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+         ('e'::('x'::('i'::('t'::[])))))), [])) :: ((CoreErlang.Coq_term_lit
+       ((CoreErlang.Coq_lit_str
+       ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+         ('a'::('x'::('i'::('o'::('m'::(' '::('t'::('o'::(' '::('b'::('e'::(' '::('r'::('e'::('a'::('l'::('i'::('z'::('e'::('d'::[])))))))))))))))))))))),
+       [])) :: [])))
+   | Miniml.MLmagic t' -> extr_ast0 e t')
+
+(** val extr_ast : Common.env -> Miniml.ml_ast -> CoreErlang.term_t **)
+
+let extr_ast e t =
+  extr_ast_func (ExistT (e, t))
+
+(** val extr_decl : Miniml.ml_decl -> CoreErlang.def_t list **)
+
+let extr_decl d =
+  let extr_decl' = fun e r t ty ->
+    if is_custom r
+    then CoreErlang.Coq_def_custom ((pp_global Term r), (find_custom r))
+    else let (bl, t') = collect_lams t in
+         let (bl0, e') = push_vars (map id_of_mlid bl) e in
+         CoreErlang.Coq_def ((CoreErlang.Coq_fname ((pp_global Term r),
+         (length bl0))), (CoreErlang.Coq_func
+         ((map (fun i -> CoreErlang.Coq_var (string_of_id i)) (rev bl0)),
+         (extr_ast e' t'))))
+  in
+  (match d with
+   | Miniml.Dind (mi, ind) -> []
+   | Miniml.Dtype (r, id, tys) -> []
+   | Miniml.Dterm (r, t, ty) -> (extr_decl'  (empty_env ())  r t ty) :: []
+   | Miniml.Dfix (rs, asts, tys) ->
+     map3 (extr_decl'  (empty_env ()) ) (Array.to_list rs)
+       (Array.to_list asts) (Array.to_list tys))
+
+(** val extr_defs :
+    (Names.label * Miniml.ml_structure_elem) list -> CoreErlang.def_t list **)
+
+let rec extr_defs x =
+  let extr_defs0 = fun defs -> extr_defs defs in
+  (match x with
+   | [] -> []
+   | d :: defs' ->
+     let (wildcard', m0) = d in
+     (match m0 with
+      | Miniml.SEdecl dec -> app (extr_decl dec) (extr_defs0 defs')
+      | Miniml.SEmodule m ->
+        let filtered_var = (function e -> e.ml_mod_expr) m in
+        (match filtered_var with
+         | Miniml.MEstruct (path', m1) ->
+           let defs'' = m1 in app (extr_defs0 defs'') (extr_defs0 defs')
+         | x0 -> extr_defs0 defs')
+      | Miniml.SEmodtype m -> extr_defs0 defs'))
+
+(** val def_names : CoreErlang.def_t list -> CoreErlang.fname_t list **)
+
+let rec def_names = function
+| [] -> []
+| d :: ds' ->
+  (match d with
+   | CoreErlang.Coq_def (n, f) ->
+     let CoreErlang.Coq_fname (a, k) = n in
+     if (=) k 0 then def_names ds' else n :: (def_names ds')
+   | CoreErlang.Coq_def_custom (c, c0) -> def_names ds')
+
+(** val extr_struct : Miniml.ml_structure -> CoreErlang.module_t list **)
+
+let extr_struct mlss =
+  let extr_struct' = fun mls ->
+    let (path, struct0) = mls in
+    let mk_defs = fun x -> let defs' = struct0 in extr_defs defs' in
+    let defs =
+      (function mp -> function sel -> function f -> push_visible mp sel; let p = f () in pop_visible (); p)
+        path [] mk_defs
+    in
+    CoreErlang.Coq_module ((string_of_mp path), (def_names defs), [], defs)
+  in
+  map extr_struct' mlss
+
+(** val str : char list -> Pp.std_ppcmds **)
+
+let str s =
+  Pp.str
+    ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+      s)
+
+(** val pp_atom : CoreErlang.atom_t -> Pp.std_ppcmds **)
+
+let pp_atom a =
+  let r' =
+    Str.regexp
+      ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+        ('\''::[]))
+  in
+  let q =
+    (function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+      ('@'::[])
+  in
+  (++) (str ('\''::[]))
+    ((++) (Pp.str (Str.global_replace r' q a)) (str ('\''::[])))
+
+(** val pp_fname : CoreErlang.fname_t -> Pp.std_ppcmds **)
+
+let pp_fname = function
+| CoreErlang.Coq_fname (a, n) ->
+  (++) (pp_atom a) ((++) (str ('/'::[])) (Pp.int (int_of_nat n)))
+
+(** val pp_concat : Pp.std_ppcmds list -> Pp.std_ppcmds **)
+
+let rec pp_concat ps =
+  fold_right (++) (str []) ps
+
+(** val pp_concat_sep :
+    Pp.std_ppcmds -> Pp.std_ppcmds list -> Pp.std_ppcmds **)
+
+let rec pp_concat_sep s = function
+| [] -> str []
+| a :: ps' ->
+  (match ps' with
+   | [] -> a
+   | s0 :: l -> (++) a ((++) s (pp_concat_sep s ps')))
+
+(** val pp_var : CoreErlang.var_t -> Pp.std_ppcmds **)
+
+let pp_var v =
+  let rlc =
+    Str.regexp
+      ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+        ('^'::('['::('a'::('-'::('z'::(']'::[])))))))
+  in
+  let r' =
+    Str.regexp
+      ((function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+        ('\''::[]))
+  in
+  let a =
+    (function s ->
+     let r = String.create (List.length s) in
+     let rec fill pos = function
+       | [] -> r
+       | c :: s -> r.[pos] <- c; fill (pos + 1) s
+     in fill 0 s)
+      ('@'::[])
+  in
+  (match v with
+   | CoreErlang.Coq_var s ->
+     let s' = Str.global_replace r' a s in
+     if Str.string_match rlc s' (int_of_nat 0)
+     then (++) (str ('_'::[])) (Pp.str s')
+     else Pp.str s'
+   | CoreErlang.Coq_var_atom s ->
+     (++) (str ('\''::[]))
+       ((++) (Pp.str (Str.global_replace r' a s)) (str ('\''::[]))))
+
+(** val pp_lit :
+    Pp.std_ppcmds -> CoreErlang.lit_t -> Pp.std_ppcmds list -> Pp.std_ppcmds **)
+
+let pp_lit spc l args =
+  match l with
+  | CoreErlang.Coq_lit_int i -> Pp.int i
+  | CoreErlang.Coq_lit_atom a -> pp_atom a
+  | CoreErlang.Coq_lit_char c -> str ('\''::(c::('\''::[])))
+  | CoreErlang.Coq_lit_str s ->
+    (++) (str ('"'::[])) ((++) (Pp.str s) (str ('"'::[])))
+  | CoreErlang.Coq_lit_nil -> str ('['::(']'::[]))
+  | CoreErlang.Coq_lit_cons s ->
+    let default =
+      if CoreErlang.atom_eq_dec s []
+      then (match args with
+            | [] ->
+              (++) (str ('{'::(' '::[])))
+                ((++)
+                  (pp_concat_sep
+                    ((++) (Pp.fnl ()) ((++) spc (str (','::(' '::[])))))
+                    args) ((++) (Pp.fnl ()) ((++) spc (str ('}'::[])))))
+            | arg :: l0 ->
+              (match l0 with
+               | [] -> (++) (str ('{'::[])) ((++) arg (str ('}'::[])))
+               | s0 :: l1 ->
+                 (++) (str ('{'::(' '::[])))
+                   ((++)
+                     (pp_concat_sep
+                       ((++) (Pp.fnl ()) ((++) spc (str (','::(' '::[])))))
+                       args) ((++) (Pp.fnl ()) ((++) spc (str ('}'::[])))))))
+      else (match args with
+            | [] -> pp_atom s
+            | arg :: l0 ->
+              (match l0 with
+               | [] ->
+                 (++) (str ('{'::[]))
+                   ((++) (pp_atom s)
+                     ((++) (str (','::(' '::[]))) ((++) arg (str ('}'::[])))))
+               | s0 :: l1 ->
+                 (++) (str ('{'::(' '::[])))
+                   ((++)
+                     (pp_concat_sep
+                       ((++) (Pp.fnl ()) ((++) spc (str (','::(' '::[])))))
+                       ((pp_atom s) :: args))
+                     ((++) (Pp.fnl ()) ((++) spc (str ('}'::[])))))))
+    in
+    if CoreErlang.atom_eq_dec s ('C'::('o'::('n'::('s'::[]))))
+    then (match args with
+          | [] -> default
+          | a :: l0 ->
+            (match l0 with
+             | [] -> default
+             | b :: l1 ->
+               (match l1 with
+                | [] ->
+                  (++) (str ('['::[]))
+                    ((++) a ((++) (str ('|'::[])) ((++) b (str (']'::[])))))
+                | s0 :: l2 -> default)))
+    else if CoreErlang.atom_eq_dec s ('N'::('i'::('l'::[])))
+         then (match args with
+               | [] -> str ('['::(']'::[]))
+               | s0 :: l0 -> default)
+         else default
+  | CoreErlang.Coq_lit_tup ->
+    (match args with
+     | [] ->
+       (++) (str ('{'::(' '::[])))
+         ((++)
+           (pp_concat_sep
+             ((++) (Pp.fnl ()) ((++) spc (str (','::(' '::[]))))) args)
+           ((++) (Pp.fnl ()) ((++) spc (str ('}'::[])))))
+     | arg :: l0 ->
+       (match l0 with
+        | [] -> (++) (str ('{'::[])) ((++) arg (str ('}'::[])))
+        | s :: l1 ->
+          (++) (str ('{'::(' '::[])))
+            ((++)
+              (pp_concat_sep
+                ((++) (Pp.fnl ()) ((++) spc (str (','::(' '::[]))))) args)
+              ((++) (Pp.fnl ()) ((++) spc (str ('}'::[])))))))
+
+(** val pp_pat : Pp.std_ppcmds -> CoreErlang.pat_t -> Pp.std_ppcmds **)
+
+let rec pp_pat spc = function
+| CoreErlang.Coq_pat_var v -> pp_var v
+| CoreErlang.Coq_pat_lit (l, ps) -> pp_lit spc l (map (pp_pat spc) ps)
+| CoreErlang.Coq_pat_alias (v, p') ->
+  (++) (pp_var v)
+    ((++) (str (' '::('='::(' '::[]))))
+      (pp_pat ((++) spc (str (' '::(' '::(' '::[]))))) p'))
+
+(** val pp_term : Pp.std_ppcmds -> CoreErlang.term_t -> Pp.std_ppcmds **)
+
+let rec pp_term spc t =
+  let pp_fun0 = fun f ->
+    let CoreErlang.Coq_func (vars, t0) = f in
+    let vars' = pp_concat_sep (str (','::(' '::[]))) (map pp_var vars) in
+    let spc' = (++) spc (str (' '::(' '::[]))) in
+    (++) (str ('f'::('u'::('n'::(' '::('('::[]))))))
+      ((++) vars'
+        ((++) (str (')'::(' '::('-'::('>'::(' '::[]))))))
+          ((++) (Pp.fnl ()) ((++) spc' (pp_term spc' t0)))))
+  in
+  let pp_clause = fun spc0 c ->
+    let spc' = (++) spc0 (str (' '::(' '::(' '::(' '::[]))))) in
+    let CoreErlang.Coq_clause (pat, guard, body) = c in
+    (++) (pp_pat spc0 pat)
+      ((++) (str (' '::('w'::('h'::('e'::('n'::(' '::[])))))))
+        ((++) (pp_term spc0 guard)
+          ((++) (str (' '::('-'::('>'::[]))))
+            ((++) (Pp.fnl ()) ((++) spc' (pp_term spc' body))))))
+  in
+  (match t with
+   | CoreErlang.Coq_term_var v -> pp_var v
+   | CoreErlang.Coq_term_fname f -> pp_fname f
+   | CoreErlang.Coq_term_lit (l, ts) -> pp_lit spc l (map (pp_term spc) ts)
+   | CoreErlang.Coq_term_fun fn -> pp_fun0 fn
+   | CoreErlang.Coq_term_let (v, t1, t2) ->
+     let spc' = (++) spc (str (' '::(' '::[]))) in
+     (++) (str ('l'::('e'::('t'::(' '::[])))))
+       ((++) (pp_var v)
+         ((++) (str (' '::('='::(' '::[]))))
+           ((++) (Pp.fnl ())
+             ((++) spc'
+               ((++) (pp_term spc' t1)
+                 ((++) (Pp.fnl ())
+                   ((++) spc
+                     ((++) (str ('i'::('n'::(' '::[]))))
+                       (pp_term ((++) spc (str (' '::(' '::(' '::[]))))) t2)))))))))
+   | CoreErlang.Coq_term_case (t0, cs) ->
+     let spc' = (++) spc (str (' '::(' '::[]))) in
+     (++) (str ('c'::('a'::('s'::('e'::(' '::[]))))))
+       ((++)
+         (pp_term ((++) spc (str (' '::(' '::(' '::(' '::(' '::[]))))))) t0)
+         ((++) (str (' '::('o'::('f'::[]))))
+           ((++) (Pp.fnl ())
+             ((++) spc'
+               ((++)
+                 (pp_concat_sep ((++) (Pp.fnl ()) spc')
+                   (map (pp_clause spc') cs))
+                 ((++) (Pp.fnl ())
+                   ((++) spc (str (' '::('e'::('n'::('d'::[]))))))))))))
+   | CoreErlang.Coq_term_letrec (defs, t0) ->
+     let pp_def = fun d ->
+       match d with
+       | CoreErlang.Coq_def (fn, f) ->
+         (++) (pp_fname fn) ((++) (str (' '::('='::(' '::[])))) (pp_fun0 f))
+       | CoreErlang.Coq_def_custom (c, b) -> str []
+     in
+     (++) (str ('l'::('e'::('t'::('r'::('e'::('c'::(' '::[]))))))))
+       ((++)
+         (pp_concat_sep
+           ((++) (Pp.fnl ())
+             ((++) spc
+               (str
+                 (' '::(' '::(' '::(' '::(' '::(' '::(' '::(' '::[])))))))))))
+           (map pp_def defs))
+         ((++) (Pp.fnl ())
+           ((++) spc
+             ((++) (str ('i'::('n'::(' '::[]))))
+               (pp_term ((++) spc (str (' '::(' '::(' '::[]))))) t0)))))
+   | CoreErlang.Coq_term_apply (t0, args) ->
+     (match args with
+      | [] ->
+        let spc' =
+          (++) (Pp.fnl ())
+            ((++) spc
+              (str
+                (' '::(' '::(' '::(' '::(' '::(' '::(','::(' '::[]))))))))))
+        in
+        let args' =
+          pp_concat_sep spc'
+            (map
+              (pp_term
+                ((++) spc
+                  (str
+                    (' '::(' '::(' '::(' '::(' '::(' '::(' '::(' '::[])))))))))))
+              args)
+        in
+        (++) (str ('a'::('p'::('p'::('l'::('y'::(' '::[])))))))
+          ((++) (pp_term ((++) spc (str (' '::(' '::[])))) t0)
+            ((++) (Pp.fnl ())
+              ((++) spc
+                ((++)
+                  (str
+                    (' '::(' '::(' '::(' '::(' '::(' '::('('::(' '::[])))))))))
+                  ((++) args'
+                    ((++) (Pp.fnl ())
+                      ((++) spc
+                        (str
+                          (' '::(' '::(' '::(' '::(' '::(' '::(')'::[])))))))))))))))
+      | arg :: l ->
+        (match l with
+         | [] ->
+           (++) (str ('a'::('p'::('p'::('l'::('y'::(' '::[])))))))
+             ((++) (pp_term ((++) spc (str (' '::(' '::[])))) t0)
+               ((++) (str (' '::('('::[])))
+                 ((++) (pp_term ((++) spc (str (' '::(' '::[])))) arg)
+                   (str (')'::[])))))
+         | t1 :: l0 ->
+           let spc' =
+             (++) (Pp.fnl ())
+               ((++) spc
+                 (str
+                   (' '::(' '::(' '::(' '::(' '::(' '::(','::(' '::[]))))))))))
+           in
+           let args' =
+             pp_concat_sep spc'
+               (map
+                 (pp_term
+                   ((++) spc
+                     (str
+                       (' '::(' '::(' '::(' '::(' '::(' '::(' '::(' '::[])))))))))))
+                 args)
+           in
+           (++) (str ('a'::('p'::('p'::('l'::('y'::(' '::[])))))))
+             ((++) (pp_term ((++) spc (str (' '::(' '::[])))) t0)
+               ((++) (Pp.fnl ())
+                 ((++) spc
+                   ((++)
+                     (str
+                       (' '::(' '::(' '::(' '::(' '::(' '::('('::(' '::[])))))))))
+                     ((++) args'
+                       ((++) (Pp.fnl ())
+                         ((++) spc
+                           (str
+                             (' '::(' '::(' '::(' '::(' '::(' '::(')'::[])))))))))))))))))
+   | CoreErlang.Coq_term_call (m, f, args) ->
+     (match args with
+      | [] ->
+        let spc' =
+          (++) (Pp.fnl ())
+            ((++) spc
+              (str (' '::(' '::(' '::(' '::(' '::(','::(' '::[])))))))))
+        in
+        let args' =
+          pp_concat_sep spc'
+            (map
+              (pp_term
+                ((++) spc
+                  (str (' '::(' '::(' '::(' '::(' '::(' '::(' '::[]))))))))))
+              args)
+        in
+        (++) (str ('c'::('a'::('l'::('l'::(' '::[]))))))
+          ((++) (pp_term ((++) spc (str (' '::(' '::[])))) m)
+            ((++) (str (':'::[]))
+              ((++) (pp_term ((++) spc (str (' '::(' '::[])))) f)
+                ((++) (Pp.fnl ())
+                  ((++) spc
+                    ((++)
+                      (str
+                        (' '::(' '::(' '::(' '::(' '::('('::(' '::[]))))))))
+                      ((++) args'
+                        ((++) (Pp.fnl ())
+                          ((++) spc
+                            (str
+                              (' '::(' '::(' '::(' '::(' '::(')'::[]))))))))))))))))
+      | arg :: l ->
+        (match l with
+         | [] ->
+           (++) (str ('c'::('a'::('l'::('l'::(' '::[]))))))
+             ((++) (pp_term ((++) spc (str (' '::(' '::[])))) m)
+               ((++) (str (':'::[]))
+                 ((++) (pp_term ((++) spc (str (' '::(' '::[])))) f)
+                   ((++) (str (' '::('('::[])))
+                     ((++) (pp_term ((++) spc (str (' '::(' '::[])))) arg)
+                       (str (')'::[])))))))
+         | t0 :: l0 ->
+           let spc' =
+             (++) (Pp.fnl ())
+               ((++) spc
+                 (str (' '::(' '::(' '::(' '::(' '::(','::(' '::[])))))))))
+           in
+           let args' =
+             pp_concat_sep spc'
+               (map
+                 (pp_term
+                   ((++) spc
+                     (str
+                       (' '::(' '::(' '::(' '::(' '::(' '::(' '::[]))))))))))
+                 args)
+           in
+           (++) (str ('c'::('a'::('l'::('l'::(' '::[]))))))
+             ((++) (pp_term ((++) spc (str (' '::(' '::[])))) m)
+               ((++) (str (':'::[]))
+                 ((++) (pp_term ((++) spc (str (' '::(' '::[])))) f)
+                   ((++) (Pp.fnl ())
+                     ((++) spc
+                       ((++)
+                         (str
+                           (' '::(' '::(' '::(' '::(' '::('('::(' '::[]))))))))
+                         ((++) args'
+                           ((++) (Pp.fnl ())
+                             ((++) spc
+                               (str
+                                 (' '::(' '::(' '::(' '::(' '::(')'::[]))))))))))))))))))
+   | CoreErlang.Coq_term_primop (a, args) ->
+     (++) (str ('p'::('r'::('i'::('m'::('o'::('p'::(' '::[]))))))))
+       ((++) (pp_atom a)
+         ((++) (str (' '::('('::[])))
+           ((++)
+             (pp_concat_sep (str (','::(' '::[])))
+               (map (pp_term (str [])) args)) (str (')'::[])))))
+   | CoreErlang.Coq_term_try (e1, vs, e2, cs, e3) ->
+     let spc' = (++) spc (str (' '::(' '::[]))) in
+     let spc'' = (++) spc' (str (' '::(' '::[]))) in
+     (++) (str ('t'::('r'::('y'::(' '::[])))))
+       ((++) (pp_term ((++) spc (str (' '::(' '::(' '::(' '::[])))))) e1)
+         ((++) (str (' '::('o'::('f'::[]))))
+           ((++) (Pp.fnl ())
+             ((++) spc'
+               ((++) (pp_concat_sep (str (','::(' '::[]))) (map pp_var vs))
+                 ((++) (str (' '::('-'::('>'::(' '::[])))))
+                   ((++) (Pp.fnl ())
+                     ((++) spc''
+                       ((++) (pp_term spc'' e2)
+                         ((++) (Pp.fnl ())
+                           ((++) spc
+                             ((++)
+                               (str
+                                 ('c'::('a'::('t'::('c'::('h'::(' '::[])))))))
+                               ((++)
+                                 (pp_concat_sep (str (','::(' '::[])))
+                                   (map pp_var vs))
+                                 ((++) (str (' '::('-'::('>'::(' '::[])))))
+                                   ((++) (Pp.fnl ())
+                                     ((++) spc'' (pp_term spc'' e3)))))))))))))))))
+   | CoreErlang.Coq_term_recv (cs, t1, t2) ->
+     let spc' = (++) spc (str (' '::(' '::[]))) in
+     (++) (str ('r'::('e'::('c'::('e'::('i'::('v'::('e'::(' '::[])))))))))
+       ((++) (pp_concat_sep (str (' '::[])) (map (pp_clause spc') cs))
+         ((++) (str (' '::('a'::('f'::('t'::('e'::('r'::[])))))))
+           ((++) (Pp.fnl ())
+             ((++) spc'
+               ((++) (pp_term spc' t1)
+                 ((++) (str (' '::('-'::('>'::[]))))
+                   ((++) (Pp.fnl ()) ((++) spc' (pp_term spc' t2)))))))))
+   | CoreErlang.Coq_term_do (t1, t2) ->
+     let spc' = (++) spc (str (' '::(' '::(' '::[])))) in
+     (++) (str ('d'::('o'::(' '::[]))))
+       ((++) (pp_term spc' t1)
+         ((++) (Pp.fnl ()) ((++) spc' (pp_term spc' t2))))
+   | CoreErlang.Coq_term_catch t0 ->
+     (++) (str ('c'::('a'::('t'::('c'::('h'::(' '::[])))))))
+       (pp_term ((++) spc (str (' '::(' '::[])))) t0)
+   | CoreErlang.Coq_term_globl s -> pp_atom s
+   | CoreErlang.Coq_term_custom s -> Pp.str s)
+
+(** val pp_fun : CoreErlang.fun_t -> Pp.std_ppcmds **)
+
+let pp_fun = function
+| CoreErlang.Coq_func (vars, t) ->
+  let vars' = pp_concat_sep (str (','::(' '::[]))) (map pp_var vars) in
+  let spc' = str (' '::(' '::[])) in
+  (++) (str ('f'::('u'::('n'::(' '::('('::[]))))))
+    ((++) vars'
+      ((++) (str (')'::(' '::('-'::('>'::(' '::[]))))))
+        ((++) (Pp.fnl ()) ((++) spc' (pp_term spc' t)))))
+
+(** val pp_decl0 : CoreErlang.def_t -> Pp.std_ppcmds **)
+
+let pp_decl0 = function
+| CoreErlang.Coq_def (fn, f) ->
+  let CoreErlang.Coq_fname (a, k) = fn in
+  if (=) k 0
+  then str []
+  else (++) (pp_fname fn) ((++) (str (' '::('='::(' '::[])))) (pp_fun f))
+| CoreErlang.Coq_def_custom (c, b) ->
+  (++) (str ('%'::(' '::[])))
+    ((++) (Pp.str c) ((++) (str (' '::('='::('>'::(' '::[]))))) (Pp.str b)))
+
+(** val pp_struct0 : CoreErlang.module_t list -> Pp.std_ppcmds **)
+
+let pp_struct0 mods =
+  let pp_struct' = fun m ->
+    let CoreErlang.Coq_module (nam, exports, attrs, defs) = m in
+    let nam' = pp_atom nam in
+    let exports' =
+      pp_concat_sep (str (','::(' '::[]))) (map pp_fname exports)
+    in
+    (++) (str ('m'::('o'::('d'::('u'::('l'::('e'::(' '::[]))))))))
+      ((++) nam'
+        ((++) (str (' '::('['::(' '::[]))))
+          ((++) exports'
+            ((++)
+              (str
+                (' '::(']'::(' '::('a'::('t'::('t'::('r'::('i'::('b'::('u'::('t'::('e'::('s'::(' '::('['::(' '::(']'::(' '::[])))))))))))))))))))
+              ((++) (Pp.fnl ())
+                ((++) (pp_concat_sep (Pp.fnl ()) (map pp_decl0 defs))
+                  ((++) (Pp.fnl ())
+                    ((++) (str ('e'::('n'::('d'::[]))))
+                      ((++) (Pp.fnl ()) (Pp.fnl ()))))))))))
+  in
+  pp_concat (map pp_struct' mods)
+
+(** val preamble0 :
+    Names.identifier -> Names.module_path list -> Miniml.unsafe_needs ->
+    Pp.std_ppcmds **)
+
+let preamble0 nam imports h =
+  str []
+
+(** val sig_preamble0 :
+    Names.identifier -> Names.module_path list -> Miniml.unsafe_needs ->
+    Pp.std_ppcmds **)
+
+let sig_preamble0 h list0 h0 =
+  str []
+
+(** val pp_sig0 : Miniml.ml_signature -> Pp.std_ppcmds **)
+
+let pp_sig0 h =
+  str []
+
+(** val coreerlang_descr : Miniml.language_descr **)
+
+let coreerlang_descr =
+  { Miniml.keywords = keywords0; Miniml.file_suffix = file_suffix0;
+    Miniml.preamble = preamble0; Miniml.pp_struct = (fun x ->
+    pp_struct0 (extr_struct x)); Miniml.sig_suffix = sig_suffix0;
+    Miniml.sig_preamble = sig_preamble0; Miniml.pp_sig = pp_sig0;
+    Miniml.pp_decl = (fun x -> pp_concat (map pp_decl0 (extr_decl x))) }
+
+
diff -aurN coq-8.4pl2-pristine/plugins/extraction/coreerlang.mli coq-8.4pl2-new/plugins/extraction/coreerlang.mli
--- coq-8.4pl2-pristine/plugins/extraction/coreerlang.mli	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/coreerlang.mli	2013-07-01 04:45:32.634113001 -0700
@@ -0,0 +1,3 @@
+
+val coreerlang_descr : Miniml.language_descr
+
diff -aurN coq-8.4pl2-pristine/plugins/extraction/extract_env.ml coq-8.4pl2-new/plugins/extraction/extract_env.ml
--- coq-8.4pl2-pristine/plugins/extraction/extract_env.ml	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/extract_env.ml	2013-06-03 04:29:10.207721636 -0700
@@ -0,0 +1,621 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+open Term
+open Declarations
+open Names
+open Libnames
+open Pp
+open Util
+open Miniml
+open Table
+open Extraction
+open Modutil
+open Common
+open Mod_subst
+
+(***************************************)
+(*S Part I: computing Coq environment. *)
+(***************************************)
+
+let toplevel_env () =
+  let seg = Lib.contents_after None in
+  let get_reference = function
+    | (_,kn), Lib.Leaf o ->
+	let mp,_,l = repr_kn kn in
+	let seb = match Libobject.object_tag o with
+	  | "CONSTANT" -> SFBconst (Global.lookup_constant (constant_of_kn kn))
+	  | "INDUCTIVE" -> SFBmind (Global.lookup_mind (mind_of_kn kn))
+	  | "MODULE" -> SFBmodule (Global.lookup_module (MPdot (mp,l)))
+	  | "MODULE TYPE" ->
+	      SFBmodtype (Global.lookup_modtype (MPdot (mp,l)))
+	  | _ -> failwith "caught"
+	in l,seb
+    | _ -> failwith "caught"
+  in
+  SEBstruct (List.rev (map_succeed get_reference seg))
+
+
+let environment_until dir_opt =
+  let rec parse = function
+    | [] when dir_opt = None -> [current_toplevel (), toplevel_env ()]
+    | [] -> []
+    | d :: l ->
+	match (Global.lookup_module (MPfile d)).mod_expr with
+	  | Some meb ->
+	      if dir_opt = Some d then [MPfile d, meb]
+	      else (MPfile d, meb) :: (parse l)
+	  | _ -> assert false
+  in parse (Library.loaded_libraries ())
+
+
+(*s Visit:
+  a structure recording the needed dependencies for the current extraction *)
+
+module type VISIT = sig
+  (* Reset the dependencies by emptying the visit lists *)
+  val reset : unit -> unit
+
+  (* Add the module_path and all its prefixes to the mp visit list *)
+  val add_mp : module_path -> unit
+
+  (* Same, but we'll keep all fields of these modules *)
+  val add_mp_all : module_path -> unit
+
+  (* Add kernel_name / constant / reference / ... in the visit lists.
+     These functions silently add the mp of their arg in the mp list *)
+  val add_ind : mutual_inductive -> unit
+  val add_con : constant -> unit
+  val add_ref : global_reference -> unit
+  val add_decl_deps : ml_decl -> unit
+  val add_spec_deps : ml_spec -> unit
+
+  (* Test functions:
+     is a particular object a needed dependency for the current extraction ? *)
+  val needed_ind : mutual_inductive -> bool
+  val needed_con : constant -> bool
+  val needed_mp : module_path -> bool
+  val needed_mp_all : module_path -> bool
+end
+
+module Visit : VISIT = struct
+  (* What used to be in a single KNset should now be split into a KNset
+     (for inductives and modules names) and a Cset_env for constants
+     (and still the remaining MPset) *)
+  type must_visit =
+      { mutable ind : KNset.t; mutable con : KNset.t;
+	mutable mp : MPset.t; mutable mp_all : MPset.t }
+  (* the imperative internal visit lists *)
+  let v = { ind = KNset.empty ; con = KNset.empty ;
+	    mp = MPset.empty; mp_all = MPset.empty }
+  (* the accessor functions *)
+  let reset () =
+    v.ind <- KNset.empty;
+    v.con <- KNset.empty;
+    v.mp <- MPset.empty;
+    v.mp_all <- MPset.empty
+  let needed_ind i = KNset.mem (user_mind i) v.ind
+  let needed_con c = KNset.mem (user_con c) v.con
+  let needed_mp mp = MPset.mem mp v.mp || MPset.mem mp v.mp_all
+  let needed_mp_all mp = MPset.mem mp v.mp_all
+  let add_mp mp =
+    check_loaded_modfile mp; v.mp <- MPset.union (prefixes_mp mp) v.mp
+  let add_mp_all mp =
+    check_loaded_modfile mp; v.mp <- MPset.union (prefixes_mp mp) v.mp;
+    v.mp_all <- MPset.add mp v.mp_all
+  let add_ind i =
+    let kn = user_mind i in
+    v.ind <- KNset.add kn v.ind; add_mp (modpath kn)
+  let add_con c =
+    let kn = user_con c in
+    v.con <- KNset.add kn v.con; add_mp (modpath kn)
+  let add_ref = function
+    | ConstRef c -> add_con c
+    | IndRef (ind,_) | ConstructRef ((ind,_),_) -> add_ind ind
+    | VarRef _ -> assert false
+  let add_decl_deps = decl_iter_references add_ref add_ref add_ref
+  let add_spec_deps = spec_iter_references add_ref add_ref add_ref
+end
+
+exception Impossible
+
+let check_arity env cb =
+  let t = Typeops.type_of_constant_type env cb.const_type in
+  if Reduction.is_arity env t then raise Impossible
+
+let check_fix env cb i =
+  match cb.const_body with
+    | Def lbody ->
+	(match kind_of_term (Declarations.force lbody) with
+	  | Fix ((_,j),recd) when i=j -> check_arity env cb; (true,recd)
+	  | CoFix (j,recd) when i=j -> check_arity env cb; (false,recd)
+	  | _ -> raise Impossible)
+    | Undef _ | OpaqueDef _ -> raise Impossible
+
+let prec_declaration_equal (na1, ca1, ta1) (na2, ca2, ta2) =
+  na1 = na2 &&
+  array_equal eq_constr ca1 ca2 &&
+  array_equal eq_constr ta1 ta2
+
+let factor_fix env l cb msb =
+  let _,recd as check = check_fix env cb 0 in
+  let n = Array.length (let fi,_,_ = recd in fi) in
+  if n = 1 then [|l|], recd, msb
+  else begin
+    if List.length msb < n-1 then raise Impossible;
+    let msb', msb'' = list_chop (n-1) msb in
+    let labels = Array.make n l in
+    list_iter_i
+      (fun j ->
+	 function
+	   | (l,SFBconst cb') ->
+	       let check' = check_fix env cb' (j+1) in
+	       if not (fst check = fst check' &&
+		   prec_declaration_equal (snd check) (snd check'))
+	       then raise Impossible;
+	       labels.(j+1) <- l;
+	   | _ -> raise Impossible) msb';
+    labels, recd, msb''
+  end
+
+(** Expanding a [struct_expr_body] into a version without abbreviations
+    or functor applications. This is done via a detour to entries
+    (hack proposed by Elie)
+*)
+
+let rec seb2mse = function
+  | SEBapply (s,s',_) -> Entries.MSEapply(seb2mse s, seb2mse s')
+  | SEBident mp -> Entries.MSEident mp
+  | _ -> failwith "seb2mse: received a non-atomic seb"
+
+let expand_seb env mp seb =
+  let seb,_,_,_ =
+    let inl = Some (Flags.get_inline_level()) in
+    Mod_typing.translate_struct_module_entry env mp inl (seb2mse seb)
+  in seb
+
+(** When possible, we use the nicer, shorter, algebraic type structures
+    instead of the expanded ones. *)
+
+let my_type_of_mb mb =
+  let m0 = mb.mod_type in
+  match mb.mod_type_alg with Some m -> m0,m | None -> m0,m0
+
+let my_type_of_mtb mtb =
+  let m0 = mtb.typ_expr in
+  match mtb.typ_expr_alg with Some m -> m0,m | None -> m0,m0
+
+(** Ad-hoc update of environment, inspired by [Mod_type.check_with_aux_def].
+    To check with Elie. *)
+
+let rec msid_of_seb = function
+  | SEBident mp -> mp
+  | SEBwith (seb,_) -> msid_of_seb seb
+  | _ -> assert false
+
+let env_for_mtb_with_def env mp seb idl =
+  let sig_b = match seb with
+    | SEBstruct(sig_b) -> sig_b
+    | _ -> assert false
+  in
+  let l = label_of_id (List.hd idl) in
+  let spot = function (l',SFBconst _) -> l = l' | _ -> false in
+  let before = fst (list_split_when spot sig_b) in
+  Modops.add_signature mp before empty_delta_resolver env
+
+(* From a [structure_body] (i.e. a list of [structure_field_body])
+   to specifications. *)
+
+let rec extract_sfb_spec env mp = function
+  | [] -> []
+  | (l,SFBconst cb) :: msig ->
+      let kn = make_con mp empty_dirpath l in
+      let s = extract_constant_spec env kn cb in
+      let specs = extract_sfb_spec env mp msig in
+      if logical_spec s then specs
+      else begin Visit.add_spec_deps s; (l,Spec s) :: specs end
+  | (l,SFBmind _) :: msig ->
+      let mind = make_mind mp empty_dirpath l in
+      let s = Sind (mind, extract_inductive env mind) in
+      let specs = extract_sfb_spec env mp msig in
+      if logical_spec s then specs
+      else begin Visit.add_spec_deps s; (l,Spec s) :: specs end
+  | (l,SFBmodule mb) :: msig ->
+      let specs = extract_sfb_spec env mp msig in
+      let spec = extract_seb_spec env mb.mod_mp (my_type_of_mb mb) in
+      (l,Smodule spec) :: specs
+  | (l,SFBmodtype mtb) :: msig ->
+      let specs = extract_sfb_spec env mp msig in
+      let spec = extract_seb_spec env mtb.typ_mp (my_type_of_mtb mtb) in
+      (l,Smodtype spec) :: specs
+
+(* From [struct_expr_body] to specifications *)
+
+(* Invariant: the [seb] given to [extract_seb_spec] should either come
+   from a [mod_type] or [type_expr] field, or their [_alg] counterparts.
+   This way, any encountered [SEBident] should be a true module type.
+*)
+
+and extract_seb_spec env mp1 (seb,seb_alg) = match seb_alg with
+  | SEBident mp -> Visit.add_mp_all mp; MTident mp
+  | SEBwith(seb',With_definition_body(idl,cb))->
+      let env' = env_for_mtb_with_def env (msid_of_seb seb') seb idl in
+      let mt = extract_seb_spec env mp1 (seb,seb') in
+      (match extract_with_type env' cb with (* cb peut contenir des kn  *)
+	 | None -> mt
+	 | Some (vl,typ) -> MTwith(mt,ML_With_type(idl,vl,typ)))
+  | SEBwith(seb',With_module_body(idl,mp))->
+      Visit.add_mp_all mp;
+      MTwith(extract_seb_spec env mp1 (seb,seb'),
+	     ML_With_module(idl,mp))
+  | SEBfunctor (mbid, mtb, seb_alg') ->
+      let seb' = match seb with
+	| SEBfunctor (mbid',_,seb') when mbid' = mbid -> seb'
+	| _ -> assert false
+      in
+      let mp = MPbound mbid in
+      let env' = Modops.add_module (Modops.module_body_of_type mp mtb) env in
+      MTfunsig (mbid, extract_seb_spec env mp (my_type_of_mtb mtb),
+		extract_seb_spec env' mp1 (seb',seb_alg'))
+  | SEBstruct (msig) ->
+      let env' = Modops.add_signature mp1 msig empty_delta_resolver env in
+      MTsig (mp1, extract_sfb_spec env' mp1 msig)
+  | SEBapply _ ->
+      if seb <> seb_alg then extract_seb_spec env mp1 (seb,seb)
+      else assert false
+
+
+
+(* From a [structure_body] (i.e. a list of [structure_field_body])
+   to implementations.
+
+   NB: when [all=false], the evaluation order of the list is
+   important: last to first ensures correct dependencies.
+*)
+
+let rec extract_sfb env mp all = function
+  | [] -> []
+  | (l,SFBconst cb) :: msb ->
+      (try
+	 let vl,recd,msb = factor_fix env l cb msb in
+	 let vc = Array.map (make_con mp empty_dirpath) vl in
+	 let ms = extract_sfb env mp all msb in
+	 let b = array_exists Visit.needed_con vc in
+	 if all || b then
+	   let d = extract_fixpoint env vc recd in
+	   if (not b) && (logical_decl d) then ms
+	   else begin Visit.add_decl_deps d; (l,SEdecl d) :: ms end
+	 else ms
+       with Impossible ->
+	 let ms = extract_sfb env mp all msb in
+	 let c = make_con mp empty_dirpath l in
+	 let b = Visit.needed_con c in
+	 if all || b then
+	   let d = extract_constant env c cb in
+	   if (not b) && (logical_decl d) then ms
+	   else begin Visit.add_decl_deps d; (l,SEdecl d) :: ms end
+	 else ms)
+  | (l,SFBmind mib) :: msb ->
+      let ms = extract_sfb env mp all msb in
+      let mind = make_mind mp empty_dirpath l in
+      let b = Visit.needed_ind mind in
+      if all || b then
+	let d = Dind (mind, extract_inductive env mind) in
+	if (not b) && (logical_decl d) then ms
+	else begin Visit.add_decl_deps d; (l,SEdecl d) :: ms end
+      else ms
+  | (l,SFBmodule mb) :: msb ->
+      let ms = extract_sfb env mp all msb in
+      let mp = MPdot (mp,l) in
+      if all || Visit.needed_mp mp then
+	(l,SEmodule (extract_module env mp true mb)) :: ms
+      else ms
+  | (l,SFBmodtype mtb) :: msb ->
+      let ms = extract_sfb env mp all msb in
+      let mp = MPdot (mp,l) in
+       if all || Visit.needed_mp mp then
+	(l,SEmodtype (extract_seb_spec env mp (my_type_of_mtb mtb))) :: ms
+      else ms
+
+(* From [struct_expr_body] to implementations *)
+
+and extract_seb env mp all = function
+  | (SEBident _ | SEBapply _) as seb when lang () <> Ocaml ->
+      (* in Haskell/Scheme, we expand everything *)
+      extract_seb env mp all (expand_seb env mp seb)
+  | SEBident mp ->
+      if is_modfile mp && not (modular ()) then error_MPfile_as_mod mp false;
+      Visit.add_mp_all mp; MEident mp
+  | SEBapply (meb, meb',_) ->
+      MEapply (extract_seb env mp true meb,
+	       extract_seb env mp true meb')
+  | SEBfunctor (mbid, mtb, meb) ->
+      let mp1 = MPbound mbid in
+      let env' = Modops.add_module (Modops.module_body_of_type  mp1 mtb)
+	env  in
+      MEfunctor (mbid, extract_seb_spec env mp1 (my_type_of_mtb mtb),
+		 extract_seb env' mp true meb)
+  | SEBstruct (msb) ->
+      let env' = Modops.add_signature mp msb empty_delta_resolver env in
+      MEstruct (mp,extract_sfb env' mp all msb)
+  | SEBwith (_,_) -> anomaly "Not available yet"
+
+and extract_module env mp all mb =
+  (* A module has an empty [mod_expr] when :
+     - it is a module variable (for instance X inside a Module F [X:SIG])
+     - it is a module assumption (Declare Module).
+     Since we look at modules from outside, we shouldn't have variables.
+     But a Declare Module at toplevel seems legal (cf #2525). For the
+     moment we don't support this situation. *)
+  match mb.mod_expr with
+    | None -> error_no_module_expr mp
+    | Some me ->
+      { ml_mod_expr = extract_seb env mp all me;
+	ml_mod_type = extract_seb_spec env mp (my_type_of_mb mb) }
+
+
+let unpack = function MEstruct (_,sel) -> sel | _ -> assert false
+
+let mono_environment refs mpl =
+  Visit.reset ();
+  List.iter Visit.add_ref refs;
+  List.iter Visit.add_mp_all mpl;
+  let env = Global.env () in
+  let l = List.rev (environment_until None) in
+  List.rev_map
+    (fun (mp,m) -> mp, unpack (extract_seb env mp (Visit.needed_mp_all mp) m))
+    l
+
+(**************************************)
+(*S Part II : Input/Output primitives *)
+(**************************************)
+
+let descr () = match lang () with
+  | Ocaml -> Ocaml.ocaml_descr
+  | Haskell -> Haskell.haskell_descr
+  | Scheme -> Scheme.scheme_descr
+  | CoreErlang -> Coreerlang.coreerlang_descr
+
+(* From a filename string "foo.ml" or "foo", builds "foo.ml" and "foo.mli"
+   Works similarly for the other languages. *)
+
+let default_id = id_of_string "Main"
+
+let mono_filename f =
+  let d = descr () in
+  match f with
+    | None -> None, None, default_id
+    | Some f ->
+	let f =
+	  if Filename.check_suffix f d.file_suffix then
+	    Filename.chop_suffix f d.file_suffix
+	  else f
+	in
+	let id =
+	  if lang () <> Haskell then default_id
+	  else
+            try id_of_string (Filename.basename f)
+	    with e when Errors.noncritical e ->
+              error "Extraction: provided filename is not a valid identifier"
+	in
+	Some (f^d.file_suffix), Option.map ((^) f) d.sig_suffix, id
+
+(* Builds a suitable filename from a module id *)
+
+let module_filename mp =
+  let f = file_of_modfile mp in
+  let d = descr () in
+  Some (f^d.file_suffix), Option.map ((^) f) d.sig_suffix, id_of_string f
+
+(*s Extraction of one decl to stdout. *)
+
+let print_one_decl struc mp decl =
+  let d = descr () in
+  reset_renaming_tables AllButExternal;
+  set_phase Pre;
+  ignore (d.pp_struct struc);
+  set_phase Impl;
+  push_visible mp [];
+  msgnl (d.pp_decl decl);
+  pop_visible ()
+
+(*s Extraction of a ml struct to a file. *)
+
+(** For Recursive Extraction, writing directly on stdout
+    won't work with coqide, we use a buffer instead *)
+
+let buf = Buffer.create 1000
+
+let formatter dry file =
+  let ft =
+    if dry then Format.make_formatter (fun _ _ _ -> ()) (fun _ -> ())
+    else
+      match file with
+	| Some f -> Pp_control.with_output_to f
+	| None -> Format.formatter_of_buffer buf
+  in
+  (* We never want to see ellipsis ... in extracted code *)
+  Format.pp_set_max_boxes ft max_int;
+  (* We reuse the width information given via "Set Printing Width" *)
+  (match Pp_control.get_margin () with
+    | None -> ()
+    | Some i ->
+      Format.pp_set_margin ft i;
+      Format.pp_set_max_indent ft (i-10));
+      (* note: max_indent should be < margin above, otherwise it's ignored *)
+  ft
+
+let print_structure_to_file (fn,si,mo) dry struc =
+  Buffer.clear buf;
+  let d = descr () in
+  reset_renaming_tables AllButExternal;
+  let unsafe_needs = {
+    mldummy = struct_ast_search ((=) MLdummy) struc;
+    tdummy = struct_type_search Mlutil.isDummy struc;
+    tunknown = struct_type_search ((=) Tunknown) struc;
+    magic =
+      if lang () <> Haskell then false
+      else struct_ast_search (function MLmagic _ -> true | _ -> false) struc }
+  in
+  (* First, a dry run, for computing objects to rename or duplicate *)
+  set_phase Pre;
+  let devnull = formatter true None in
+  msg_with devnull (d.pp_struct struc);
+  let opened = opened_libraries () in
+  (* Print the implementation *)
+  let cout = if dry then None else Option.map open_out fn in
+  let ft = formatter dry cout in
+  begin try
+    (* The real printing of the implementation *)
+    set_phase Impl;
+    msg_with ft (d.preamble mo opened unsafe_needs);
+    msg_with ft (d.pp_struct struc);
+    Option.iter close_out cout;
+  with reraise ->
+    Option.iter close_out cout; raise reraise
+  end;
+  if not dry then Option.iter info_file fn;
+  (* Now, let's print the signature *)
+  Option.iter
+    (fun si ->
+       let cout = open_out si in
+       let ft = formatter false (Some cout) in
+       begin try
+	 set_phase Intf;
+	 msg_with ft (d.sig_preamble mo opened unsafe_needs);
+	 msg_with ft (d.pp_sig (signature_of_structure struc));
+	 close_out cout;
+       with reraise ->
+	 close_out cout; raise reraise
+       end;
+       info_file si)
+    (if dry then None else si);
+  (* Print the buffer content via Coq standard formatter (ok with coqide). *)
+  if Buffer.length buf <> 0 then begin
+    Pp.message (Buffer.contents buf);
+    Buffer.reset buf
+  end
+
+
+(*********************************************)
+(*s Part III: the actual extraction commands *)
+(*********************************************)
+
+
+let reset () =
+  Visit.reset (); reset_tables (); reset_renaming_tables Everything
+
+let init modular library =
+  check_inside_section (); check_inside_module ();
+  set_keywords (descr ()).keywords;
+  set_modular modular;
+  set_library library;
+  reset ();
+  if modular && lang () = Scheme then error_scheme ()
+
+let warns () =
+  warning_opaques (access_opaque ());
+  warning_axioms ()
+
+(* From a list of [reference], let's retrieve whether they correspond
+   to modules or [global_reference]. Warn the user if both is possible. *)
+
+let rec locate_ref = function
+  | [] -> [],[]
+  | r::l ->
+      let q = snd (qualid_of_reference r) in
+      let mpo = try Some (Nametab.locate_module q) with Not_found -> None
+      and ro =
+        try Some (Smartlocate.global_with_alias r)
+        with e when Errors.noncritical e -> None
+      in
+      match mpo, ro with
+	| None, None -> Nametab.error_global_not_found q
+	| None, Some r -> let refs,mps = locate_ref l in r::refs,mps
+	| Some mp, None -> let refs,mps = locate_ref l in refs,mp::mps
+	| Some mp, Some r ->
+	    warning_both_mod_and_cst q mp r;
+	    let refs,mps = locate_ref l in refs,mp::mps
+
+(*s Recursive extraction in the Coq toplevel. The vernacular command is
+    \verb!Recursive Extraction! [qualid1] ... [qualidn]. Also used when
+    extracting to a file with the command:
+    \verb!Extraction "file"! [qualid1] ... [qualidn]. *)
+
+let full_extr f (refs,mps) =
+  init false false;
+  List.iter (fun mp -> if is_modfile mp then error_MPfile_as_mod mp true) mps;
+  let struc = optimize_struct (refs,mps) (mono_environment refs mps) in
+  warns ();
+  print_structure_to_file (mono_filename f) false struc;
+  reset ()
+
+let full_extraction f lr = full_extr f (locate_ref lr)
+
+(*s Separate extraction is similar to recursive extraction, with the output
+   decomposed in many files, one per Coq .v file *)
+
+let separate_extraction lr =
+  init true false;
+  let refs,mps = locate_ref lr in
+  let struc = optimize_struct (refs,mps) (mono_environment refs mps) in
+  warns ();
+  let print = function
+    | (MPfile dir as mp, sel) as e ->
+	print_structure_to_file (module_filename mp) false [e]
+    | _ -> assert false
+  in
+  List.iter print struc;
+  reset ()
+
+(*s Simple extraction in the Coq toplevel. The vernacular command
+    is \verb!Extraction! [qualid]. *)
+
+let simple_extraction r =
+  Vernacentries.dump_global (Genarg.AN r);
+  match locate_ref [r] with
+  | ([], [mp]) as p -> full_extr None p
+  | [r],[] ->
+      init false false;
+      let struc = optimize_struct ([r],[]) (mono_environment [r] []) in
+      let d = get_decl_in_structure r struc in
+      warns ();
+      if is_custom r then msgnl (str "(** User defined extraction *)");
+      print_one_decl struc (modpath_of_r r) d;
+      reset ()
+  | _ -> assert false
+
+
+(*s (Recursive) Extraction of a library. The vernacular command is
+  \verb!(Recursive) Extraction Library! [M]. *)
+
+let extraction_library is_rec m =
+  init true true;
+  let dir_m =
+    let q = qualid_of_ident m in
+    try Nametab.full_name_module q with Not_found -> error_unknown_module q
+  in
+  Visit.add_mp_all (MPfile dir_m);
+  let env = Global.env () in
+  let l = List.rev (environment_until (Some dir_m)) in
+  let select l (mp,meb) =
+    if Visit.needed_mp mp
+    then (mp, unpack (extract_seb env mp true meb)) :: l
+    else l
+  in
+  let struc = List.fold_left select [] l in
+  let struc = optimize_struct ([],[]) struc in
+  warns ();
+  let print = function
+    | (MPfile dir as mp, sel) as e ->
+	let dry = not is_rec && dir <> dir_m in
+	print_structure_to_file (module_filename mp) dry [e]
+    | _ -> assert false
+  in
+  List.iter print struc;
+  reset ()
diff -aurN coq-8.4pl2-pristine/plugins/extraction/extraction_plugin.mllib coq-8.4pl2-new/plugins/extraction/extraction_plugin.mllib
--- coq-8.4pl2-pristine/plugins/extraction/extraction_plugin.mllib	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/extraction_plugin.mllib	2013-07-01 04:45:32.634113001 -0700
@@ -0,0 +1,15 @@
+Peano
+Specif
+Datatypes
+Table
+Mlutil
+Modutil
+Extraction
+Common
+Ocaml
+Haskell
+Scheme
+Coreerlang
+Extract_env
+G_extraction
+Extraction_plugin_mod
diff -aurN coq-8.4pl2-pristine/plugins/extraction/g_extraction.ml4 coq-8.4pl2-new/plugins/extraction/g_extraction.ml4
--- coq-8.4pl2-pristine/plugins/extraction/g_extraction.ml4	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/g_extraction.ml4	2013-06-03 04:29:10.207721636 -0700
@@ -0,0 +1,150 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+(*i camlp4deps: "parsing/grammar.cma" i*)
+
+(* ML names *)
+
+open Vernacexpr
+open Pcoq
+open Genarg
+open Pp
+open Names
+open Nameops
+open Table
+open Extract_env
+
+let pr_mlname _ _ _ s = spc () ++ qs s
+
+ARGUMENT EXTEND mlname
+  TYPED AS string
+  PRINTED BY pr_mlname
+| [ preident(id) ] -> [ id ]
+| [ string(s) ] -> [ s ]
+END
+
+let pr_int_or_id _ _ _ = function
+  | ArgInt i -> int i
+  | ArgId id -> pr_id id
+
+ARGUMENT EXTEND int_or_id
+  TYPED AS int_or_id
+  PRINTED BY pr_int_or_id
+| [ preident(id) ] -> [ ArgId (id_of_string id) ]
+| [ integer(i) ] -> [ ArgInt i ]
+END
+
+let pr_language = function
+  | Ocaml -> str "Ocaml"
+  | Haskell -> str "Haskell"
+  | Scheme -> str "Scheme"
+  | CoreErlang -> str "CoreErlang"
+
+VERNAC ARGUMENT EXTEND language
+PRINTED BY pr_language
+| [ "Ocaml" ] -> [ Ocaml ]
+| [ "Haskell" ] -> [ Haskell ]
+| [ "Scheme" ] -> [ Scheme ]
+| [ "CoreErlang" ] -> [ CoreErlang ]
+END
+
+(* Extraction commands *)
+
+VERNAC COMMAND EXTEND Extraction
+(* Extraction in the Coq toplevel *)
+| [ "Extraction" global(x) ] -> [ simple_extraction x ]
+| [ "Recursive" "Extraction" ne_global_list(l) ] -> [ full_extraction None l ]
+
+(* Monolithic extraction to a file *)
+| [ "Extraction" string(f) ne_global_list(l) ]
+  -> [ full_extraction (Some f) l ]
+END
+
+VERNAC COMMAND EXTEND SeparateExtraction
+(* Same, with content splitted in several files *)
+| [ "Separate" "Extraction" ne_global_list(l) ]
+  -> [ separate_extraction l ]
+END
+
+(* Modular extraction (one Coq library = one ML module) *)
+VERNAC COMMAND EXTEND ExtractionLibrary
+| [ "Extraction" "Library" ident(m) ]
+  -> [ extraction_library false m ]
+END
+
+VERNAC COMMAND EXTEND RecursiveExtractionLibrary
+| [ "Recursive" "Extraction" "Library" ident(m) ]
+  -> [ extraction_library true m ]
+END
+
+(* Target Language *)
+VERNAC COMMAND EXTEND ExtractionLanguage
+| [ "Extraction" "Language" language(l) ]
+  -> [ extraction_language l ]
+END
+
+VERNAC COMMAND EXTEND ExtractionInline
+(* Custom inlining directives *)
+| [ "Extraction" "Inline" ne_global_list(l) ]
+  -> [ extraction_inline true l ]
+END
+
+VERNAC COMMAND EXTEND ExtractionNoInline
+| [ "Extraction" "NoInline" ne_global_list(l) ]
+  -> [ extraction_inline false l ]
+END
+
+VERNAC COMMAND EXTEND PrintExtractionInline
+| [ "Print" "Extraction" "Inline" ]
+  -> [ print_extraction_inline () ]
+END
+
+VERNAC COMMAND EXTEND ResetExtractionInline
+| [ "Reset" "Extraction" "Inline" ]
+  -> [ reset_extraction_inline () ]
+END
+
+VERNAC COMMAND EXTEND ExtractionImplicit
+(* Custom implicit arguments of some csts/inds/constructors *)
+| [ "Extraction" "Implicit" global(r) "[" int_or_id_list(l) "]" ]
+  -> [ extraction_implicit r l ]
+END
+
+VERNAC COMMAND EXTEND ExtractionBlacklist
+(* Force Extraction to not use some filenames *)
+| [ "Extraction" "Blacklist" ne_ident_list(l) ]
+  -> [ extraction_blacklist l ]
+END
+
+VERNAC COMMAND EXTEND PrintExtractionBlacklist
+| [ "Print" "Extraction" "Blacklist" ]
+  -> [ print_extraction_blacklist () ]
+END
+
+VERNAC COMMAND EXTEND ResetExtractionBlacklist
+| [ "Reset" "Extraction" "Blacklist" ]
+  -> [ reset_extraction_blacklist () ]
+END
+
+
+(* Overriding of a Coq object by an ML one *)
+VERNAC COMMAND EXTEND ExtractionConstant
+| [ "Extract" "Constant" global(x) string_list(idl) "=>" mlname(y) ]
+  -> [ extract_constant_inline false x idl y ]
+END
+
+VERNAC COMMAND EXTEND ExtractionInlinedConstant
+| [ "Extract" "Inlined" "Constant" global(x) "=>" mlname(y) ]
+  -> [ extract_constant_inline true x [] y ]
+END
+
+VERNAC COMMAND EXTEND ExtractionInductive
+| [ "Extract" "Inductive" global(x) "=>"
+    mlname(id) "[" mlname_list(idl) "]" string_opt(o) ]
+  -> [ extract_inductive x id idl o ]
+END
diff -aurN coq-8.4pl2-pristine/plugins/extraction/table.ml coq-8.4pl2-new/plugins/extraction/table.ml
--- coq-8.4pl2-pristine/plugins/extraction/table.ml	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/table.ml	2013-06-03 04:29:10.207721636 -0700
@@ -0,0 +1,869 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+open Names
+open Term
+open Declarations
+open Nameops
+open Namegen
+open Summary
+open Libobject
+open Goptions
+open Libnames
+open Util
+open Pp
+open Miniml
+
+(** Sets and maps for [global_reference] that use the "user" [kernel_name]
+    instead of the canonical one *)
+
+module Refmap' = Map.Make(RefOrdered_env)
+module Refset' = Set.Make(RefOrdered_env)
+
+(*S Utilities about [module_path] and [kernel_names] and [global_reference] *)
+
+let occur_kn_in_ref kn = function
+  | IndRef (kn',_)
+  | ConstructRef ((kn',_),_) -> kn = kn'
+  | ConstRef _ -> false
+  | VarRef _ -> assert false
+
+let repr_of_r = function
+  | ConstRef kn -> repr_con kn
+  | IndRef (kn,_)
+  | ConstructRef ((kn,_),_) -> repr_mind kn
+  | VarRef _ -> assert false
+
+let modpath_of_r r =
+  let mp,_,_ = repr_of_r r in mp
+
+let label_of_r r =
+  let _,_,l = repr_of_r r in l
+
+let rec base_mp = function
+  | MPdot (mp,l) -> base_mp mp
+  | mp -> mp
+
+let is_modfile = function
+  | MPfile _ -> true
+  | _ -> false
+
+let raw_string_of_modfile = function
+  | MPfile f -> String.capitalize (string_of_id (List.hd (repr_dirpath f)))
+  | _ -> assert false
+
+let current_toplevel () = fst (Lib.current_prefix ())
+
+let is_toplevel mp =
+  mp = initial_path || mp = current_toplevel ()
+
+let at_toplevel mp =
+  is_modfile mp || is_toplevel mp
+
+let rec mp_length mp =
+  let mp0 = current_toplevel () in
+  let rec len = function
+    | mp when mp = mp0 -> 1
+    | MPdot (mp,_) -> 1 + len mp
+    | _ -> 1
+  in len mp
+
+let visible_con kn = at_toplevel (base_mp (con_modpath kn))
+
+let rec prefixes_mp mp = match mp with
+  | MPdot (mp',_) -> MPset.add mp (prefixes_mp mp')
+  | _ -> MPset.singleton mp
+
+let rec get_nth_label_mp n = function
+  | MPdot (mp,l) -> if n=1 then l else get_nth_label_mp (n-1) mp
+  | _ -> failwith "get_nth_label: not enough MPdot"
+
+let common_prefix_from_list mp0 mpl =
+  let prefixes = prefixes_mp mp0 in
+  let rec f = function
+    | [] -> None
+    | mp :: l -> if MPset.mem mp prefixes then Some mp else f l
+  in f mpl
+
+let rec parse_labels2 ll mp1 = function
+  | mp when mp1=mp -> mp,ll
+  | MPdot (mp,l) -> parse_labels2 (l::ll) mp1 mp
+  | mp -> mp,ll
+
+let labels_of_ref r =
+  let mp_top = current_toplevel () in
+  let mp,_,l = repr_of_r r in
+  parse_labels2 [l] mp_top mp
+
+
+(*S The main tables: constants, inductives, records, ... *)
+
+(* Theses tables are not registered within coq save/undo mechanism
+   since we reset their contents at each run of Extraction *)
+
+(*s Constants tables. *)
+
+let terms = ref (Cmap_env.empty : ml_decl Cmap_env.t)
+let init_terms () = terms := Cmap_env.empty
+let add_term kn d = terms := Cmap_env.add kn d !terms
+let lookup_term kn = Cmap_env.find kn !terms
+
+let types = ref (Cmap_env.empty : ml_schema Cmap_env.t)
+let init_types () = types := Cmap_env.empty
+let add_type kn s = types := Cmap_env.add kn s !types
+let lookup_type kn = Cmap_env.find kn !types
+
+(*s Inductives table. *)
+
+let inductives =
+  ref (Mindmap_env.empty : (mutual_inductive_body * ml_ind) Mindmap_env.t)
+let init_inductives () = inductives := Mindmap_env.empty
+let add_ind kn mib ml_ind =
+  inductives := Mindmap_env.add kn (mib,ml_ind) !inductives
+let lookup_ind kn = Mindmap_env.find kn !inductives
+
+let inductive_kinds =
+  ref (Mindmap_env.empty : inductive_kind Mindmap_env.t)
+let init_inductive_kinds () = inductive_kinds := Mindmap_env.empty
+let add_inductive_kind kn k =
+    inductive_kinds := Mindmap_env.add kn k !inductive_kinds
+let is_coinductive r =
+  let kn = match r with
+    | ConstructRef ((kn,_),_) -> kn
+    | IndRef (kn,_) -> kn
+    | _ -> assert false
+  in
+  try Mindmap_env.find kn !inductive_kinds = Coinductive
+  with Not_found -> false
+
+let is_coinductive_type = function
+  | Tglob (r,_) -> is_coinductive r
+  | _ -> false
+
+let get_record_fields r =
+  let kn = match r with
+    | ConstructRef ((kn,_),_) -> kn
+    | IndRef (kn,_) -> kn
+    | _ -> assert false
+  in
+  try match Mindmap_env.find kn !inductive_kinds with
+    | Record f -> f
+    | _ -> []
+  with Not_found -> []
+
+let record_fields_of_type = function
+  | Tglob (r,_) -> get_record_fields r
+  | _ -> []
+
+(*s Recursors table. *)
+
+(* NB: here we can use the equivalence between canonical
+   and user constant names : Cset is fine, no need for [Cset_env] *)
+
+let recursors = ref Cset.empty
+let init_recursors () = recursors := Cset.empty
+
+let add_recursors env kn =
+  let mk_con id =
+    make_con_equiv
+      (modpath (user_mind kn))
+      (modpath (canonical_mind kn))
+      empty_dirpath (label_of_id id)
+  in
+  let mib = Environ.lookup_mind kn env in
+  Array.iter
+    (fun mip ->
+       let id = mip.mind_typename in
+       let c_rec = mk_con (Nameops.add_suffix id "_rec")
+       and c_rect = mk_con (Nameops.add_suffix id "_rect") in
+       recursors := Cset.add c_rec (Cset.add c_rect !recursors))
+    mib.mind_packets
+
+let is_recursor = function
+  | ConstRef kn -> Cset.mem kn !recursors
+  | _ -> false
+
+(*s Record tables. *)
+
+(* NB: here, working modulo name equivalence is ok *)
+
+let projs = ref (Refmap.empty : int Refmap.t)
+let init_projs () = projs := Refmap.empty
+let add_projection n kn = projs := Refmap.add (ConstRef kn) n !projs
+let is_projection r = Refmap.mem r !projs
+let projection_arity r = Refmap.find r !projs
+
+(*s Table of used axioms *)
+
+let info_axioms = ref Refset'.empty
+let log_axioms = ref Refset'.empty
+let init_axioms () = info_axioms := Refset'.empty; log_axioms := Refset'.empty
+let add_info_axiom r = info_axioms := Refset'.add r !info_axioms
+let remove_info_axiom r = info_axioms := Refset'.remove r !info_axioms
+let add_log_axiom r = log_axioms := Refset'.add r !log_axioms
+
+let opaques = ref Refset'.empty
+let init_opaques () = opaques := Refset'.empty
+let add_opaque r = opaques := Refset'.add r !opaques
+let remove_opaque r = opaques := Refset'.remove r !opaques
+
+(*s Extraction modes: modular or monolithic, library or minimal ?
+
+Nota:
+ - Recursive Extraction : monolithic, minimal
+ - Separate Extraction : modular, minimal
+ - Extraction Library : modular, library
+*)
+
+let modular_ref = ref false
+let library_ref = ref false
+
+let set_modular b = modular_ref := b
+let modular () = !modular_ref
+
+let set_library b = library_ref := b
+let library () = !library_ref
+
+(*s Printing. *)
+
+(* The following functions work even on objects not in [Global.env ()].
+   Warning: for inductive objects, this only works if an [extract_inductive]
+   have been done earlier, otherwise we can only ask the Nametab about
+   currently visible objects. *)
+
+let safe_basename_of_global r =
+  let last_chance r =
+    try Nametab.basename_of_global r
+    with Not_found ->
+      anomaly "Inductive object unknown to extraction and not globally visible"
+  in
+  match r with
+    | ConstRef kn -> id_of_label (con_label kn)
+    | IndRef (kn,0) -> id_of_label (mind_label kn)
+    | IndRef (kn,i) ->
+      (try (snd (lookup_ind kn)).ind_packets.(i).ip_typename
+       with Not_found -> last_chance r)
+    | ConstructRef ((kn,i),j) ->
+      (try (snd (lookup_ind kn)).ind_packets.(i).ip_consnames.(j-1)
+       with Not_found -> last_chance r)
+    | VarRef _ -> assert false
+
+let string_of_global r =
+ try string_of_qualid (Nametab.shortest_qualid_of_global Idset.empty r)
+ with e when Errors.noncritical e -> string_of_id (safe_basename_of_global r)
+
+let safe_pr_global r = str (string_of_global r)
+
+(* idem, but with qualification, and only for constants. *)
+
+let safe_pr_long_global r =
+  try Printer.pr_global r
+  with e when Errors.noncritical e -> match r with
+    | ConstRef kn ->
+	let mp,_,l = repr_con kn in
+	str ((string_of_mp mp)^"."^(string_of_label l))
+    | _ -> assert false
+
+let pr_long_mp mp =
+  let lid = repr_dirpath (Nametab.dirpath_of_module mp) in
+  str (String.concat "." (List.map string_of_id (List.rev lid)))
+
+let pr_long_global ref = pr_path (Nametab.path_of_global ref)
+
+(*S Warning and Error messages. *)
+
+let err s = errorlabstrm "Extraction" s
+
+let warning_axioms () =
+  let info_axioms = Refset'.elements !info_axioms in
+  if info_axioms = [] then ()
+  else begin
+    let s = if List.length info_axioms = 1 then "axiom" else "axioms" in
+    msg_warning
+      (str ("The following "^s^" must be realized in the extracted code:")
+       ++ hov 1 (spc () ++ prlist_with_sep spc safe_pr_global info_axioms)
+       ++ str "." ++ fnl ())
+  end;
+  let log_axioms = Refset'.elements !log_axioms in
+  if log_axioms = [] then ()
+  else begin
+    let s = if List.length log_axioms = 1 then "axiom was" else "axioms were"
+    in
+    msg_warning
+      (str ("The following logical "^s^" encountered:") ++
+       hov 1
+         (spc () ++ prlist_with_sep spc safe_pr_global log_axioms ++ str ".\n")
+       ++
+       str "Having invalid logical axiom in the environment when extracting" ++
+       spc () ++ str "may lead to incorrect or non-terminating ML terms." ++
+       fnl ())
+  end;
+  if !Flags.load_proofs = Flags.Dont && info_axioms@log_axioms <> [] then
+    msg_warning
+      (str "Some of these axioms might be due to option -dont-load-proofs.")
+
+let warning_opaques accessed =
+  let opaques = Refset'.elements !opaques in
+  if opaques = [] then ()
+  else
+    let lst = hov 1 (spc () ++ prlist_with_sep spc safe_pr_global opaques) in
+    if accessed then
+      msg_warning
+	(str "The extraction is currently set to bypass opacity,\n" ++
+	 str "the following opaque constant bodies have been accessed :" ++
+	 lst ++ str "." ++ fnl ())
+    else
+      msg_warning
+	(str "The extraction now honors the opacity constraints by default,\n" ++
+	 str "the following opaque constants have been extracted as axioms :" ++
+	 lst ++ str "." ++ fnl () ++
+	 str "If necessary, use \"Set Extraction AccessOpaque\" to change this."
+	 ++ fnl ())
+
+let warning_both_mod_and_cst q mp r =
+ msg_warning
+   (str "The name " ++ pr_qualid q ++ str " is ambiguous, " ++
+    str "do you mean module " ++
+    pr_long_mp mp ++
+    str " or object " ++
+    pr_long_global r ++ str " ?" ++ fnl () ++
+    str "First choice is assumed, for the second one please use " ++
+    str "fully qualified name." ++ fnl ())
+
+let error_axiom_scheme r i =
+  err (str "The type scheme axiom " ++ spc () ++
+       safe_pr_global r ++ spc () ++ str "needs " ++ pr_int i ++
+       str " type variable(s).")
+
+let check_inside_module () =
+  if Lib.is_modtype () then
+    err (str "You can't do that within a Module Type." ++ fnl () ++
+	 str "Close it and try again.")
+  else if Lib.is_module () then
+    msg_warning
+      (str "Extraction inside an opened module is experimental.\n" ++
+       str "In case of problem, close it first.\n")
+
+let check_inside_section () =
+  if Lib.sections_are_opened () then
+    err (str "You can't do that within a section." ++ fnl () ++
+	 str "Close it and try again.")
+
+let warning_id s =
+  msg_warning (str ("The identifier "^s^
+		    " contains __ which is reserved for the extraction"))
+
+let error_constant r =
+  err (safe_pr_global r ++ str " is not a constant.")
+
+let error_inductive r =
+  err (safe_pr_global r ++ spc () ++ str "is not an inductive type.")
+
+let error_nb_cons () =
+  err (str "Not the right number of constructors.")
+
+let error_module_clash mp1 mp2 =
+  err (str "The Coq modules " ++ pr_long_mp mp1 ++ str " and " ++
+       pr_long_mp mp2 ++ str " have the same ML name.\n" ++
+       str "This is not supported yet. Please do some renaming first.")
+
+let error_no_module_expr mp =
+  err (str "The module " ++ pr_long_mp mp
+       ++ str " has no body, it probably comes from\n"
+       ++ str "some Declare Module outside any Module Type.\n"
+       ++ str "This situation is currently unsupported by the extraction.")
+
+let error_singleton_become_prop id =
+  err (str "The informative inductive type " ++ pr_id id ++
+       str " has a Prop instance.\n" ++
+       str "This happens when a sort-polymorphic singleton inductive type\n" ++
+       str "has logical parameters, such as (I,I) : (True * True) : Prop.\n" ++
+       str "The Ocaml extraction cannot handle this situation yet.\n" ++
+       str "Instead, use a sort-monomorphic type such as (True /\\ True)\n" ++
+       str "or extract to Haskell.")
+
+let error_unknown_module m =
+  err (str "Module" ++ spc () ++ pr_qualid m ++ spc () ++ str "not found.")
+
+let error_scheme () =
+  err (str "No Scheme modular extraction available yet.")
+
+let error_not_visible r =
+  err (safe_pr_global r ++ str " is not directly visible.\n" ++
+       str "For example, it may be inside an applied functor.\n" ++
+       str "Use Recursive Extraction to get the whole environment.")
+
+let error_MPfile_as_mod mp b =
+  let s1 = if b then "asked" else "required" in
+  let s2 = if b then "extract some objects of this module or\n" else "" in
+  err (str ("Extraction of file "^(raw_string_of_modfile mp)^
+	    ".v as a module is "^s1^".\n"^
+	    "Monolithic Extraction cannot deal with this situation.\n"^
+	    "Please "^s2^"use (Recursive) Extraction Library instead.\n"))
+
+let msg_non_implicit r n id =
+  let name = match id with
+    | Anonymous -> ""
+    | Name id -> "(" ^ string_of_id id ^ ") "
+  in
+  "The " ^ (ordinal n) ^ " argument " ^ name ^ "of " ^ (string_of_global r)
+
+let error_non_implicit msg =
+  err (str (msg ^ " still occurs after extraction.") ++
+       fnl () ++ str "Please check the Extraction Implicit declarations.")
+
+let check_loaded_modfile mp = match base_mp mp with
+  | MPfile dp ->
+      if not (Library.library_is_loaded dp) then begin
+	match base_mp (current_toplevel ()) with
+	  | MPfile dp' when dp<>dp' ->
+	      err (str ("Please load library "^(string_of_dirpath dp^" first.")))
+	  | _ -> ()
+      end
+  | _ -> ()
+
+let info_file f =
+  Flags.if_verbose message
+    ("The file "^f^" has been created by extraction.")
+
+
+(*S The Extraction auxiliary commands *)
+
+(* The objects defined below should survive an arbitrary time,
+   so we register them to coq save/undo mechanism. *)
+
+let my_bool_option name initval =
+  let flag = ref initval in
+  let access = fun () -> !flag in
+  let _ = declare_bool_option
+    {optsync = true;
+     optdepr = false;
+     optname = "Extraction "^name;
+     optkey = ["Extraction"; name];
+     optread = access;
+     optwrite = (:=) flag }
+  in
+  access
+
+(*s Extraction AccessOpaque *)
+
+let access_opaque = my_bool_option "AccessOpaque" true
+
+(*s Extraction AutoInline *)
+
+let auto_inline = my_bool_option "AutoInline" false
+
+(*s Extraction TypeExpand *)
+
+let type_expand = my_bool_option "TypeExpand" true
+
+(*s Extraction KeepSingleton *)
+
+let keep_singleton = my_bool_option "KeepSingleton" false
+
+(*s Extraction Optimize *)
+
+type opt_flag =
+    { opt_kill_dum : bool; (* 1 *)
+      opt_fix_fun : bool;   (* 2 *)
+      opt_case_iot : bool;  (* 4 *)
+      opt_case_idr : bool;  (* 8 *)
+      opt_case_idg : bool;  (* 16 *)
+      opt_case_cst : bool;  (* 32 *)
+      opt_case_fun : bool;  (* 64 *)
+      opt_case_app : bool;  (* 128 *)
+      opt_let_app : bool;   (* 256 *)
+      opt_lin_let : bool;   (* 512 *)
+      opt_lin_beta : bool } (* 1024 *)
+
+let kth_digit n k = (n land (1 lsl k) <> 0)
+
+let flag_of_int n =
+    { opt_kill_dum = kth_digit n 0;
+      opt_fix_fun = kth_digit n 1;
+      opt_case_iot = kth_digit n 2;
+      opt_case_idr = kth_digit n 3;
+      opt_case_idg = kth_digit n 4;
+      opt_case_cst = kth_digit n 5;
+      opt_case_fun = kth_digit n 6;
+      opt_case_app = kth_digit n 7;
+      opt_let_app = kth_digit n 8;
+      opt_lin_let = kth_digit n 9;
+      opt_lin_beta = kth_digit n 10 }
+
+(* For the moment, we allow by default everything except :
+   - the type-unsafe optimization [opt_case_idg], which anyway
+     cannot be activated currently (cf [Mlutil.branch_as_fun])
+   - the linear let and beta reduction [opt_lin_let] and [opt_lin_beta]
+     (may lead to complexity blow-up, subsumed by finer reductions
+      when inlining recursors).
+*)
+
+let int_flag_init = 1 + 2 + 4 + 8 (*+ 16*) + 32 + 64 + 128 + 256 (*+ 512 + 1024*)
+
+let int_flag_ref = ref int_flag_init
+let opt_flag_ref = ref (flag_of_int int_flag_init)
+
+let chg_flag n = int_flag_ref := n; opt_flag_ref := flag_of_int n
+
+let optims () = !opt_flag_ref
+
+let _ = declare_bool_option
+	  {optsync = true;
+           optdepr = false;
+	   optname = "Extraction Optimize";
+	   optkey = ["Extraction"; "Optimize"];
+	   optread = (fun () -> !int_flag_ref <> 0);
+	   optwrite = (fun b -> chg_flag (if b then int_flag_init else 0))}
+
+let _ = declare_int_option
+          { optsync = true;
+            optdepr = false;
+            optname = "Extraction Flag";
+            optkey = ["Extraction";"Flag"];
+            optread = (fun _ -> Some !int_flag_ref);
+            optwrite = (function
+                          | None -> chg_flag 0
+                          | Some i -> chg_flag (max i 0))}
+
+
+(*s Extraction Lang *)
+
+type lang = Ocaml | Haskell | Scheme | CoreErlang
+
+let lang_ref = ref Ocaml
+
+let lang () = !lang_ref
+
+let extr_lang : lang -> obj =
+  declare_object
+    {(default_object "Extraction Lang") with
+       cache_function = (fun (_,l) -> lang_ref := l);
+       load_function = (fun _ (_,l) -> lang_ref := l)}
+
+let _ = declare_summary "Extraction Lang"
+	  { freeze_function = (fun () -> !lang_ref);
+	    unfreeze_function = ((:=) lang_ref);
+	    init_function = (fun () -> lang_ref := Ocaml) }
+
+let extraction_language x = Lib.add_anonymous_leaf (extr_lang x)
+
+(*s Extraction Inline/NoInline *)
+
+let empty_inline_table = (Refset'.empty,Refset'.empty)
+
+let inline_table = ref empty_inline_table
+
+let to_inline r = Refset'.mem r (fst !inline_table)
+
+let to_keep r = Refset'.mem r (snd !inline_table)
+
+let add_inline_entries b l =
+  let f b = if b then Refset'.add else Refset'.remove in
+  let i,k = !inline_table in
+  inline_table :=
+  (List.fold_right (f b) l i),
+  (List.fold_right (f (not b)) l k)
+
+(* Registration of operations for rollback. *)
+
+let inline_extraction : bool * global_reference list -> obj =
+  declare_object
+    {(default_object "Extraction Inline") with
+       cache_function = (fun (_,(b,l)) -> add_inline_entries b l);
+       load_function = (fun _ (_,(b,l)) -> add_inline_entries b l);
+       classify_function = (fun o -> Substitute o);
+       discharge_function =
+	(fun (_,(b,l)) -> Some (b, List.map pop_global_reference l));
+       subst_function =
+        (fun (s,(b,l)) -> (b,(List.map (fun x -> fst (subst_global s x)) l)))
+    }
+
+let _ = declare_summary "Extraction Inline"
+	  { freeze_function = (fun () -> !inline_table);
+	    unfreeze_function = ((:=) inline_table);
+	    init_function = (fun () -> inline_table := empty_inline_table) }
+
+(* Grammar entries. *)
+
+let extraction_inline b l =
+  let refs = List.map Smartlocate.global_with_alias l in
+  List.iter
+    (fun r -> match r with
+       | ConstRef _ -> ()
+       | _ -> error_constant r) refs;
+  Lib.add_anonymous_leaf (inline_extraction (b,refs))
+
+(* Printing part *)
+
+let print_extraction_inline () =
+  let (i,n)= !inline_table in
+  let i'= Refset'.filter (function ConstRef _ -> true | _ -> false) i in
+  msg
+    (str "Extraction Inline:" ++ fnl () ++
+     Refset'.fold
+       (fun r p ->
+	  (p ++ str "  " ++ safe_pr_long_global r ++ fnl ())) i' (mt ()) ++
+     str "Extraction NoInline:" ++ fnl () ++
+     Refset'.fold
+       (fun r p ->
+	  (p ++ str "  " ++ safe_pr_long_global r ++ fnl ())) n (mt ()))
+
+(* Reset part *)
+
+let reset_inline : unit -> obj =
+  declare_object
+    {(default_object "Reset Extraction Inline") with
+       cache_function = (fun (_,_)-> inline_table :=  empty_inline_table);
+       load_function = (fun _ (_,_)-> inline_table :=  empty_inline_table)}
+
+let reset_extraction_inline () = Lib.add_anonymous_leaf (reset_inline ())
+
+(*s Extraction Implicit *)
+
+type int_or_id = ArgInt of int | ArgId of identifier
+
+let implicits_table = ref Refmap'.empty
+
+let implicits_of_global r =
+ try Refmap'.find r !implicits_table with Not_found -> []
+
+let add_implicits r l =
+  let typ = Global.type_of_global r in
+  let rels,_ =
+    decompose_prod (Reduction.whd_betadeltaiota (Global.env ()) typ) in
+  let names = List.rev_map fst rels in
+  let n = List.length names in
+  let check = function
+    | ArgInt i ->
+	if 1 <= i && i <= n then i
+	else err (int i ++ str " is not a valid argument number for " ++
+		  safe_pr_global r)
+    | ArgId id ->
+	(try list_index (Name id) names
+	 with Not_found ->
+	   err (str "No argument " ++ pr_id id ++ str " for " ++
+		safe_pr_global r))
+  in
+  let l' = List.map check l in
+  implicits_table := Refmap'.add r l' !implicits_table
+
+(* Registration of operations for rollback. *)
+
+let implicit_extraction : global_reference * int_or_id list -> obj =
+  declare_object
+    {(default_object "Extraction Implicit") with
+       cache_function = (fun (_,(r,l)) -> add_implicits r l);
+       load_function = (fun _ (_,(r,l)) -> add_implicits r l);
+       classify_function = (fun o -> Substitute o);
+       subst_function = (fun (s,(r,l)) -> (fst (subst_global s r), l))
+    }
+
+let _ = declare_summary "Extraction Implicit"
+	  { freeze_function = (fun () -> !implicits_table);
+	    unfreeze_function = ((:=) implicits_table);
+	    init_function = (fun () -> implicits_table := Refmap'.empty) }
+
+(* Grammar entries. *)
+
+let extraction_implicit r l =
+  check_inside_section ();
+  Lib.add_anonymous_leaf (implicit_extraction (Smartlocate.global_with_alias r,l))
+
+
+(*s Extraction Blacklist of filenames not to use while extracting *)
+
+let blacklist_table = ref Idset.empty
+
+let modfile_ids = ref []
+let modfile_mps = ref MPmap.empty
+
+let reset_modfile () =
+  modfile_ids := Idset.elements !blacklist_table;
+  modfile_mps := MPmap.empty
+
+let string_of_modfile mp =
+  try MPmap.find mp !modfile_mps
+  with Not_found ->
+    let id = id_of_string (raw_string_of_modfile mp) in
+    let id' = next_ident_away id !modfile_ids in
+    let s' = string_of_id id' in
+    modfile_ids := id' :: !modfile_ids;
+    modfile_mps := MPmap.add mp s' !modfile_mps;
+    s'
+
+(* same as [string_of_modfile], but preserves the capital/uncapital 1st char *)
+
+let file_of_modfile mp =
+  let s0 = match mp with
+    | MPfile f -> string_of_id (List.hd (repr_dirpath f))
+    | _ -> assert false
+  in
+  let s = String.copy (string_of_modfile mp) in
+  if s.[0] <> s0.[0] then s.[0] <- s0.[0];
+  s
+
+let add_blacklist_entries l =
+  blacklist_table :=
+    List.fold_right (fun s -> Idset.add (id_of_string (String.capitalize s)))
+      l !blacklist_table
+
+(* Registration of operations for rollback. *)
+
+let blacklist_extraction : string list -> obj =
+  declare_object
+    {(default_object "Extraction Blacklist") with
+       cache_function = (fun (_,l) -> add_blacklist_entries l);
+       load_function = (fun _ (_,l) -> add_blacklist_entries l);
+       subst_function = (fun (_,x) -> x)
+    }
+
+let _ = declare_summary "Extraction Blacklist"
+	  { freeze_function = (fun () -> !blacklist_table);
+	    unfreeze_function = ((:=) blacklist_table);
+	    init_function = (fun () -> blacklist_table := Idset.empty) }
+
+(* Grammar entries. *)
+
+let extraction_blacklist l =
+  let l = List.rev_map string_of_id l in
+  Lib.add_anonymous_leaf (blacklist_extraction l)
+
+(* Printing part *)
+
+let print_extraction_blacklist () =
+  msgnl
+    (prlist_with_sep fnl pr_id (Idset.elements !blacklist_table))
+
+(* Reset part *)
+
+let reset_blacklist : unit -> obj =
+  declare_object
+    {(default_object "Reset Extraction Blacklist") with
+       cache_function = (fun (_,_)-> blacklist_table := Idset.empty);
+       load_function = (fun _ (_,_)-> blacklist_table := Idset.empty)}
+
+let reset_extraction_blacklist () = Lib.add_anonymous_leaf (reset_blacklist ())
+
+(*s Extract Constant/Inductive. *)
+
+(* UGLY HACK: to be defined in [extraction.ml] *)
+let use_type_scheme_nb_args, register_type_scheme_nb_args =
+  let r = ref (fun _ _ -> 0) in (fun x y -> !r x y), (:=) r
+
+let customs = ref Refmap'.empty
+
+let add_custom r ids s = customs := Refmap'.add r (ids,s) !customs
+
+let is_custom r = Refmap'.mem r !customs
+
+let is_inline_custom r = (is_custom r) && (to_inline r)
+
+let find_custom r = snd (Refmap'.find r !customs)
+
+let find_type_custom r = Refmap'.find r !customs
+
+let custom_matchs = ref Refmap'.empty
+
+let add_custom_match r s =
+  custom_matchs := Refmap'.add r s !custom_matchs
+
+let indref_of_match pv =
+  if Array.length pv = 0 then raise Not_found;
+  let (_,pat,_) = pv.(0) in
+  match pat with
+    | Pusual (ConstructRef (ip,_)) -> IndRef ip
+    | Pcons (ConstructRef (ip,_),_) -> IndRef ip
+    | _ -> raise Not_found
+
+let is_custom_match pv =
+  try Refmap'.mem (indref_of_match pv) !custom_matchs
+  with Not_found -> false
+
+let find_custom_match pv =
+  Refmap'.find (indref_of_match pv) !custom_matchs
+
+(* Registration of operations for rollback. *)
+
+let in_customs : global_reference * string list * string -> obj =
+  declare_object
+    {(default_object "ML extractions") with
+       cache_function = (fun (_,(r,ids,s)) -> add_custom r ids s);
+       load_function = (fun _ (_,(r,ids,s)) -> add_custom r ids s);
+       classify_function = (fun o -> Substitute o);
+       subst_function =
+        (fun (s,(r,ids,str)) -> (fst (subst_global s r), ids, str))
+    }
+
+let _ = declare_summary "ML extractions"
+	  { freeze_function = (fun () -> !customs);
+	    unfreeze_function = ((:=) customs);
+	    init_function = (fun () -> customs := Refmap'.empty) }
+
+let in_custom_matchs : global_reference * string -> obj =
+  declare_object
+    {(default_object "ML extractions custom matchs") with
+       cache_function = (fun (_,(r,s)) -> add_custom_match r s);
+       load_function = (fun _ (_,(r,s)) -> add_custom_match r s);
+       classify_function = (fun o -> Substitute o);
+       subst_function = (fun (subs,(r,s)) -> (fst (subst_global subs r), s))
+    }
+
+let _ = declare_summary "ML extractions custom match"
+	  { freeze_function = (fun () -> !custom_matchs);
+	    unfreeze_function = ((:=) custom_matchs);
+	    init_function = (fun () -> custom_matchs := Refmap'.empty) }
+
+(* Grammar entries. *)
+
+let extract_constant_inline inline r ids s =
+  check_inside_section ();
+  let g = Smartlocate.global_with_alias r in
+  match g with
+    | ConstRef kn ->
+	let env = Global.env () in
+	let typ = Typeops.type_of_constant env kn in
+	let typ = Reduction.whd_betadeltaiota env typ in
+	if Reduction.is_arity env typ
+	  then begin
+	    let nargs = use_type_scheme_nb_args env typ in
+	    if List.length ids <> nargs then error_axiom_scheme g nargs
+	  end;
+	Lib.add_anonymous_leaf (inline_extraction (inline,[g]));
+	Lib.add_anonymous_leaf (in_customs (g,ids,s))
+    | _ -> error_constant g
+
+
+let extract_inductive r s l optstr =
+  check_inside_section ();
+  let g = Smartlocate.global_with_alias r in
+  Dumpglob.add_glob (loc_of_reference r) g;
+  match g with
+    | IndRef ((kn,i) as ip) ->
+	let mib = Global.lookup_mind kn in
+	let n = Array.length mib.mind_packets.(i).mind_consnames in
+	if n <> List.length l then error_nb_cons ();
+	Lib.add_anonymous_leaf (inline_extraction (true,[g]));
+	Lib.add_anonymous_leaf (in_customs (g,[],s));
+	Option.iter (fun s -> Lib.add_anonymous_leaf (in_custom_matchs (g,s)))
+	  optstr;
+	list_iter_i
+	  (fun j s ->
+	     let g = ConstructRef (ip,succ j) in
+	     Lib.add_anonymous_leaf (inline_extraction (true,[g]));
+	     Lib.add_anonymous_leaf (in_customs (g,[],s))) l
+    | _ -> error_inductive g
+
+
+
+(*s Tables synchronization. *)
+
+let reset_tables () =
+  init_terms (); init_types (); init_inductives ();
+  init_inductive_kinds (); init_recursors ();
+  init_projs (); init_axioms (); init_opaques (); reset_modfile ()
diff -aurN coq-8.4pl2-pristine/plugins/extraction/table.mli coq-8.4pl2-new/plugins/extraction/table.mli
--- coq-8.4pl2-pristine/plugins/extraction/table.mli	1969-12-31 16:00:00.000000000 -0800
+++ coq-8.4pl2-new/plugins/extraction/table.mli	2013-06-03 04:29:10.207721636 -0700
@@ -0,0 +1,197 @@
+(************************************************************************)
+(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
+(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2012     *)
+(*   \VV/  **************************************************************)
+(*    //   *      This file is distributed under the terms of the       *)
+(*         *       GNU Lesser General Public License Version 2.1        *)
+(************************************************************************)
+
+open Names
+open Libnames
+open Miniml
+open Declarations
+
+module Refset' : Set.S with type elt = global_reference
+module Refmap' : Map.S with type key = global_reference
+
+val safe_basename_of_global : global_reference -> identifier
+
+(*s Warning and Error messages. *)
+
+val warning_axioms : unit -> unit
+val warning_opaques : bool -> unit
+val warning_both_mod_and_cst :
+ qualid -> module_path -> global_reference -> unit
+val warning_id : string -> unit
+val error_axiom_scheme : global_reference -> int -> 'a
+val error_constant : global_reference -> 'a
+val error_inductive : global_reference -> 'a
+val error_nb_cons : unit -> 'a
+val error_module_clash : module_path -> module_path -> 'a
+val error_no_module_expr : module_path -> 'a
+val error_singleton_become_prop : identifier -> 'a
+val error_unknown_module : qualid -> 'a
+val error_scheme : unit -> 'a
+val error_not_visible : global_reference -> 'a
+val error_MPfile_as_mod : module_path -> bool -> 'a
+val check_inside_module : unit -> unit
+val check_inside_section : unit -> unit
+val check_loaded_modfile : module_path -> unit
+val msg_non_implicit : global_reference -> int -> name -> string
+val error_non_implicit : string -> 'a
+
+val info_file : string -> unit
+
+(*s utilities about [module_path] and [kernel_names] and [global_reference] *)
+
+val occur_kn_in_ref : mutual_inductive -> global_reference -> bool
+val repr_of_r : global_reference -> module_path * dir_path * label
+val modpath_of_r : global_reference -> module_path
+val label_of_r : global_reference -> label
+val current_toplevel : unit -> module_path
+val base_mp : module_path -> module_path
+val is_modfile : module_path -> bool
+val string_of_modfile : module_path -> string
+val file_of_modfile : module_path -> string
+val is_toplevel : module_path -> bool
+val at_toplevel : module_path -> bool
+val visible_con : constant -> bool
+val mp_length : module_path -> int
+val prefixes_mp : module_path -> MPset.t
+val common_prefix_from_list :
+  module_path -> module_path list -> module_path option
+val get_nth_label_mp : int -> module_path -> label
+val labels_of_ref : global_reference -> module_path * label list
+
+(*s Some table-related operations *)
+
+val add_term : constant -> ml_decl -> unit
+val lookup_term : constant -> ml_decl
+
+val add_type : constant -> ml_schema -> unit
+val lookup_type : constant -> ml_schema
+
+val add_ind : mutual_inductive -> mutual_inductive_body -> ml_ind -> unit
+val lookup_ind : mutual_inductive -> mutual_inductive_body * ml_ind
+
+val add_inductive_kind : mutual_inductive -> inductive_kind -> unit
+val is_coinductive : global_reference -> bool
+val is_coinductive_type : ml_type -> bool
+(* What are the fields of a record (empty for a non-record) *)
+val get_record_fields :
+  global_reference -> global_reference option list
+val record_fields_of_type : ml_type -> global_reference option list
+
+val add_recursors : Environ.env -> mutual_inductive -> unit
+val is_recursor : global_reference -> bool
+
+val add_projection : int -> constant -> unit
+val is_projection : global_reference -> bool
+val projection_arity : global_reference -> int
+
+val add_info_axiom : global_reference -> unit
+val remove_info_axiom : global_reference -> unit
+val add_log_axiom : global_reference -> unit
+
+val add_opaque : global_reference -> unit
+val remove_opaque : global_reference -> unit
+
+val reset_tables : unit -> unit
+
+(*s AccessOpaque parameter *)
+
+val access_opaque : unit -> bool
+
+(*s AutoInline parameter *)
+
+val auto_inline : unit -> bool
+
+(*s TypeExpand parameter *)
+
+val type_expand : unit -> bool
+
+(*s KeepSingleton parameter *)
+
+val keep_singleton : unit -> bool
+
+(*s Optimize parameter *)
+
+type opt_flag =
+    { opt_kill_dum : bool; (* 1 *)
+      opt_fix_fun : bool;   (* 2 *)
+      opt_case_iot : bool;  (* 4 *)
+      opt_case_idr : bool;  (* 8 *)
+      opt_case_idg : bool;  (* 16 *)
+      opt_case_cst : bool;  (* 32 *)
+      opt_case_fun : bool;  (* 64 *)
+      opt_case_app : bool;  (* 128 *)
+      opt_let_app : bool;   (* 256 *)
+      opt_lin_let : bool;   (* 512 *)
+      opt_lin_beta : bool } (* 1024 *)
+
+val optims :  unit -> opt_flag
+
+(*s Target language. *)
+
+type lang = Ocaml | Haskell | Scheme | CoreErlang
+val lang : unit -> lang
+
+(*s Extraction modes: modular or monolithic, library or minimal ?
+
+Nota:
+ - Recursive Extraction : monolithic, minimal
+ - Separate Extraction : modular, minimal
+ - Extraction Library : modular, library
+*)
+
+val set_modular : bool -> unit
+val modular : unit -> bool
+
+val set_library : bool -> unit
+val library : unit -> bool
+
+(*s Table for custom inlining *)
+
+val to_inline : global_reference -> bool
+val to_keep : global_reference -> bool
+
+(*s Table for implicits arguments *)
+
+val implicits_of_global : global_reference -> int list
+
+(*s Table for user-given custom ML extractions. *)
+
+(* UGLY HACK: registration of a function defined in [extraction.ml] *)
+val register_type_scheme_nb_args : (Environ.env -> Term.constr -> int) -> unit
+
+val is_custom : global_reference -> bool
+val is_inline_custom : global_reference -> bool
+val find_custom : global_reference -> string
+val find_type_custom : global_reference -> string list * string
+
+val is_custom_match : ml_branch array -> bool
+val find_custom_match : ml_branch array -> string
+
+(*s Extraction commands. *)
+
+val extraction_language : lang -> unit
+val extraction_inline : bool -> reference list -> unit
+val print_extraction_inline : unit -> unit
+val reset_extraction_inline : unit -> unit
+val extract_constant_inline :
+  bool -> reference -> string list -> string -> unit
+val extract_inductive :
+  reference -> string -> string list -> string option -> unit
+
+
+type int_or_id = ArgInt of int | ArgId of identifier
+val extraction_implicit : reference -> int_or_id list -> unit
+
+(*s Table of blacklisted filenames *)
+
+val extraction_blacklist : identifier list -> unit
+val reset_extraction_blacklist : unit -> unit
+val print_extraction_blacklist : unit -> unit
+
+
+
